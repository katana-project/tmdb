// Code generated by ogen, DO NOT EDIT.

package tmdb

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AccountAddFavorite invokes account-add-favorite operation.
	//
	// Add Favorite.
	//
	// POST /3/account/{account_id}/favorite
	AccountAddFavorite(ctx context.Context, request OptAccountAddFavoriteReq, params AccountAddFavoriteParams) (*AccountAddFavoriteOK, error)
	// AccountAddToWatchlist invokes account-add-to-watchlist operation.
	//
	// Add To Watchlist.
	//
	// POST /3/account/{account_id}/watchlist
	AccountAddToWatchlist(ctx context.Context, request OptAccountAddToWatchlistReq, params AccountAddToWatchlistParams) (*AccountAddToWatchlistOK, error)
	// AccountDetails invokes account-details operation.
	//
	// Details.
	//
	// GET /3/account/{account_id}
	AccountDetails(ctx context.Context, params AccountDetailsParams) (*AccountDetailsOK, error)
	// AccountFavoriteTv invokes account-favorite-tv operation.
	//
	// Favorite TV.
	//
	// GET /3/account/{account_id}/favorite/tv
	AccountFavoriteTv(ctx context.Context, params AccountFavoriteTvParams) (*AccountFavoriteTvOK, error)
	// AccountGetFavorites invokes account-get-favorites operation.
	//
	// Favorite Movies.
	//
	// GET /3/account/{account_id}/favorite/movies
	AccountGetFavorites(ctx context.Context, params AccountGetFavoritesParams) (*AccountGetFavoritesOK, error)
	// AccountLists invokes account-lists operation.
	//
	// Lists.
	//
	// GET /3/account/{account_id}/lists
	AccountLists(ctx context.Context, params AccountListsParams) (*AccountListsOK, error)
	// AccountRatedMovies invokes account-rated-movies operation.
	//
	// Rated Movies.
	//
	// GET /3/account/{account_id}/rated/movies
	AccountRatedMovies(ctx context.Context, params AccountRatedMoviesParams) (*AccountRatedMoviesOK, error)
	// AccountRatedTv invokes account-rated-tv operation.
	//
	// Rated TV.
	//
	// GET /3/account/{account_id}/rated/tv
	AccountRatedTv(ctx context.Context, params AccountRatedTvParams) (*AccountRatedTvOK, error)
	// AccountRatedTvEpisodes invokes account-rated-tv-episodes operation.
	//
	// Rated TV Episodes.
	//
	// GET /3/account/{account_id}/rated/tv/episodes
	AccountRatedTvEpisodes(ctx context.Context, params AccountRatedTvEpisodesParams) (*AccountRatedTvEpisodesOK, error)
	// AccountWatchlistMovies invokes account-watchlist-movies operation.
	//
	// Watchlist Movies.
	//
	// GET /3/account/{account_id}/watchlist/movies
	AccountWatchlistMovies(ctx context.Context, params AccountWatchlistMoviesParams) (*AccountWatchlistMoviesOK, error)
	// AccountWatchlistTv invokes account-watchlist-tv operation.
	//
	// Watchlist TV.
	//
	// GET /3/account/{account_id}/watchlist/tv
	AccountWatchlistTv(ctx context.Context, params AccountWatchlistTvParams) (*AccountWatchlistTvOK, error)
	// AlternativeNamesCopy invokes alternative-names-copy operation.
	//
	// Get the TV network logos by id.
	//
	// GET /3/network/{network_id}/images
	AlternativeNamesCopy(ctx context.Context, params AlternativeNamesCopyParams) (*AlternativeNamesCopyOK, error)
	// AuthenticationCreateGuestSession invokes authentication-create-guest-session operation.
	//
	// Create Guest Session.
	//
	// GET /3/authentication/guest_session/new
	AuthenticationCreateGuestSession(ctx context.Context) (*AuthenticationCreateGuestSessionOK, error)
	// AuthenticationCreateRequestToken invokes authentication-create-request-token operation.
	//
	// Create Request Token.
	//
	// GET /3/authentication/token/new
	AuthenticationCreateRequestToken(ctx context.Context) (*AuthenticationCreateRequestTokenOK, error)
	// AuthenticationCreateSession invokes authentication-create-session operation.
	//
	// Create Session.
	//
	// POST /3/authentication/session/new
	AuthenticationCreateSession(ctx context.Context, request OptAuthenticationCreateSessionReq) (*AuthenticationCreateSessionOK, error)
	// AuthenticationCreateSessionFromLogin invokes authentication-create-session-from-login operation.
	//
	// This method allows an application to validate a request token by entering a username and password.
	//
	// POST /3/authentication/token/validate_with_login
	AuthenticationCreateSessionFromLogin(ctx context.Context, request OptAuthenticationCreateSessionFromLoginReq) (*AuthenticationCreateSessionFromLoginOK, error)
	// AuthenticationCreateSessionFromV4Token invokes authentication-create-session-from-v4-token operation.
	//
	// Create Session (from v4 token).
	//
	// POST /3/authentication/session/convert/4
	AuthenticationCreateSessionFromV4Token(ctx context.Context, request OptAuthenticationCreateSessionFromV4TokenReq) (*AuthenticationCreateSessionFromV4TokenOK, error)
	// AuthenticationDeleteSession invokes authentication-delete-session operation.
	//
	// Delete Session.
	//
	// DELETE /3/authentication/session
	AuthenticationDeleteSession(ctx context.Context, request OptAuthenticationDeleteSessionReq) (*AuthenticationDeleteSessionOK, error)
	// AuthenticationValidateKey invokes authentication-validate-key operation.
	//
	// Test your API Key to see if it's valid.
	//
	// GET /3/authentication
	AuthenticationValidateKey(ctx context.Context) (AuthenticationValidateKeyRes, error)
	// CertificationMovieList invokes certification-movie-list operation.
	//
	// Get an up to date list of the officially supported movie certifications on TMDB.
	//
	// GET /3/certification/movie/list
	CertificationMovieList(ctx context.Context) (*CertificationMovieListOK, error)
	// CertificationsTvList invokes certifications-tv-list operation.
	//
	// TV Certifications.
	//
	// GET /3/certification/tv/list
	CertificationsTvList(ctx context.Context) (*CertificationsTvListOK, error)
	// ChangesMovieList invokes changes-movie-list operation.
	//
	// Get a list of all of the movie ids that have been changed in the past 24 hours.
	//
	// GET /3/movie/changes
	ChangesMovieList(ctx context.Context, params ChangesMovieListParams) (*ChangesMovieListOK, error)
	// ChangesPeopleList invokes changes-people-list operation.
	//
	// People List.
	//
	// GET /3/person/changes
	ChangesPeopleList(ctx context.Context, params ChangesPeopleListParams) (*ChangesPeopleListOK, error)
	// ChangesTvList invokes changes-tv-list operation.
	//
	// TV List.
	//
	// GET /3/tv/changes
	ChangesTvList(ctx context.Context, params ChangesTvListParams) (*ChangesTvListOK, error)
	// CollectionDetails invokes collection-details operation.
	//
	// Get collection details by ID.
	//
	// GET /3/collection/{collection_id}
	CollectionDetails(ctx context.Context, params CollectionDetailsParams) (*CollectionDetailsOK, error)
	// CollectionImages invokes collection-images operation.
	//
	// Get the images that belong to a collection.
	//
	// GET /3/collection/{collection_id}/images
	CollectionImages(ctx context.Context, params CollectionImagesParams) (*CollectionImagesOK, error)
	// CollectionTranslations invokes collection-translations operation.
	//
	// Translations.
	//
	// GET /3/collection/{collection_id}/translations
	CollectionTranslations(ctx context.Context, params CollectionTranslationsParams) (*CollectionTranslationsOK, error)
	// CompanyAlternativeNames invokes company-alternative-names operation.
	//
	// Get the company details by ID.
	//
	// GET /3/company/{company_id}/alternative_names
	CompanyAlternativeNames(ctx context.Context, params CompanyAlternativeNamesParams) (*CompanyAlternativeNamesOK, error)
	// CompanyDetails invokes company-details operation.
	//
	// Get the company details by ID.
	//
	// GET /3/company/{company_id}
	CompanyDetails(ctx context.Context, params CompanyDetailsParams) (*CompanyDetailsOK, error)
	// CompanyImages invokes company-images operation.
	//
	// Get the company logos by id.
	//
	// GET /3/company/{company_id}/images
	CompanyImages(ctx context.Context, params CompanyImagesParams) (*CompanyImagesOK, error)
	// ConfigurationCountries invokes configuration-countries operation.
	//
	// Get the list of countries (ISO 3166-1 tags) used throughout TMDB.
	//
	// GET /3/configuration/countries
	ConfigurationCountries(ctx context.Context, params ConfigurationCountriesParams) ([]ConfigurationCountriesOKItem, error)
	// ConfigurationDetails invokes configuration-details operation.
	//
	// Query the API configuration details.
	//
	// GET /3/configuration
	ConfigurationDetails(ctx context.Context) (*ConfigurationDetailsOK, error)
	// ConfigurationJobs invokes configuration-jobs operation.
	//
	// Get the list of the jobs and departments we use on TMDB.
	//
	// GET /3/configuration/jobs
	ConfigurationJobs(ctx context.Context) ([]ConfigurationJobsOKItem, error)
	// ConfigurationLanguages invokes configuration-languages operation.
	//
	// Get the list of languages (ISO 639-1 tags) used throughout TMDB.
	//
	// GET /3/configuration/languages
	ConfigurationLanguages(ctx context.Context) ([]ConfigurationLanguagesOKItem, error)
	// ConfigurationPrimaryTranslations invokes configuration-primary-translations operation.
	//
	// Get a list of the officially supported translations on TMDB.
	//
	// GET /3/configuration/primary_translations
	ConfigurationPrimaryTranslations(ctx context.Context) ([]string, error)
	// ConfigurationTimezones invokes configuration-timezones operation.
	//
	// Get the list of timezones used throughout TMDB.
	//
	// GET /3/configuration/timezones
	ConfigurationTimezones(ctx context.Context) ([]ConfigurationTimezonesOKItem, error)
	// CreditDetails invokes credit-details operation.
	//
	// Get a movie or TV credit details by ID.
	//
	// GET /3/credit/{credit_id}
	CreditDetails(ctx context.Context, params CreditDetailsParams) (*CreditDetailsOK, error)
	// DetailsCopy invokes details-copy operation.
	//
	// Get the alternative names of a network.
	//
	// GET /3/network/{network_id}/alternative_names
	DetailsCopy(ctx context.Context, params DetailsCopyParams) (*DetailsCopyOK, error)
	// DiscoverMovie invokes discover-movie operation.
	//
	// Find movies using over 30 filters and sort options.
	//
	// GET /3/discover/movie
	DiscoverMovie(ctx context.Context, params DiscoverMovieParams) (*DiscoverMovieOK, error)
	// DiscoverTv invokes discover-tv operation.
	//
	// Find TV shows using over 30 filters and sort options.
	//
	// GET /3/discover/tv
	DiscoverTv(ctx context.Context, params DiscoverTvParams) (*DiscoverTvOK, error)
	// FindByID invokes find-by-id operation.
	//
	// Find data by external ID's.
	//
	// GET /3/find/{external_id}
	FindByID(ctx context.Context, params FindByIDParams) (*FindByIDOK, error)
	// GenreMovieList invokes genre-movie-list operation.
	//
	// Get the list of official genres for movies.
	//
	// GET /3/genre/movie/list
	GenreMovieList(ctx context.Context, params GenreMovieListParams) (*GenreMovieListOK, error)
	// GenreTvList invokes genre-tv-list operation.
	//
	// Get the list of official genres for TV shows.
	//
	// GET /3/genre/tv/list
	GenreTvList(ctx context.Context, params GenreTvListParams) (*GenreTvListOK, error)
	// GuestSessionRatedMovies invokes guest-session-rated-movies operation.
	//
	// Get the rated movies for a guest session.
	//
	// GET /3/guest_session/{guest_session_id}/rated/movies
	GuestSessionRatedMovies(ctx context.Context, params GuestSessionRatedMoviesParams) (*GuestSessionRatedMoviesOK, error)
	// GuestSessionRatedTv invokes guest-session-rated-tv operation.
	//
	// Get the rated TV shows for a guest session.
	//
	// GET /3/guest_session/{guest_session_id}/rated/tv
	GuestSessionRatedTv(ctx context.Context, params GuestSessionRatedTvParams) (*GuestSessionRatedTvOK, error)
	// GuestSessionRatedTvEpisodes invokes guest-session-rated-tv-episodes operation.
	//
	// Get the rated TV episodes for a guest session.
	//
	// GET /3/guest_session/{guest_session_id}/rated/tv/episodes
	GuestSessionRatedTvEpisodes(ctx context.Context, params GuestSessionRatedTvEpisodesParams) (*GuestSessionRatedTvEpisodesOK, error)
	// KeywordDetails invokes keyword-details operation.
	//
	// Details.
	//
	// GET /3/keyword/{keyword_id}
	KeywordDetails(ctx context.Context, params KeywordDetailsParams) (*KeywordDetailsOK, error)
	// KeywordMovies invokes keyword-movies operation.
	//
	// Movies.
	//
	// GET /3/keyword/{keyword_id}/movies
	KeywordMovies(ctx context.Context, params KeywordMoviesParams) (*KeywordMoviesOK, error)
	// ListAddMovie invokes list-add-movie operation.
	//
	// Add a movie to a list.
	//
	// POST /3/list/{list_id}/add_item
	ListAddMovie(ctx context.Context, request OptListAddMovieReq, params ListAddMovieParams) (*ListAddMovieOK, error)
	// ListCheckItemStatus invokes list-check-item-status operation.
	//
	// Use this method to check if an item has already been added to the list.
	//
	// GET /3/list/{list_id}/item_status
	ListCheckItemStatus(ctx context.Context, params ListCheckItemStatusParams) (*ListCheckItemStatusOK, error)
	// ListClear invokes list-clear operation.
	//
	// Clear all items from a list.
	//
	// POST /3/list/{list_id}/clear
	ListClear(ctx context.Context, params ListClearParams) (*ListClearOK, error)
	// ListCreate invokes list-create operation.
	//
	// Create.
	//
	// POST /3/list
	ListCreate(ctx context.Context, request OptListCreateReq, params ListCreateParams) (*ListCreateOK, error)
	// ListDelete invokes list-delete operation.
	//
	// Delete a list.
	//
	// DELETE /3/list/{list_id}
	ListDelete(ctx context.Context, params ListDeleteParams) (*ListDeleteOK, error)
	// ListDetails invokes list-details operation.
	//
	// Details.
	//
	// GET /3/list/{list_id}
	ListDetails(ctx context.Context, params ListDetailsParams) (*ListDetailsOK, error)
	// ListRemoveMovie invokes list-remove-movie operation.
	//
	// Remove a movie from a list.
	//
	// POST /3/list/{list_id}/remove_item
	ListRemoveMovie(ctx context.Context, request OptListRemoveMovieReq, params ListRemoveMovieParams) (*ListRemoveMovieOK, error)
	// MovieAccountStates invokes movie-account-states operation.
	//
	// Get the rating, watchlist and favourite status of an account.
	//
	// GET /3/movie/{movie_id}/account_states
	MovieAccountStates(ctx context.Context, params MovieAccountStatesParams) (*MovieAccountStatesOK, error)
	// MovieAddRating invokes movie-add-rating operation.
	//
	// Rate a movie and save it to your rated list.
	//
	// POST /3/movie/{movie_id}/rating
	MovieAddRating(ctx context.Context, request OptMovieAddRatingReq, params MovieAddRatingParams) (*MovieAddRatingOK, error)
	// MovieAlternativeTitles invokes movie-alternative-titles operation.
	//
	// Get the alternative titles for a movie.
	//
	// GET /3/movie/{movie_id}/alternative_titles
	MovieAlternativeTitles(ctx context.Context, params MovieAlternativeTitlesParams) (*MovieAlternativeTitlesOK, error)
	// MovieChanges invokes movie-changes operation.
	//
	// Get the recent changes for a movie.
	//
	// GET /3/movie/{movie_id}/changes
	MovieChanges(ctx context.Context, params MovieChangesParams) (*MovieChangesOK, error)
	// MovieCredits invokes movie-credits operation.
	//
	// Credits.
	//
	// GET /3/movie/{movie_id}/credits
	MovieCredits(ctx context.Context, params MovieCreditsParams) (*MovieCreditsOK, error)
	// MovieDeleteRating invokes movie-delete-rating operation.
	//
	// Delete a user rating.
	//
	// DELETE /3/movie/{movie_id}/rating
	MovieDeleteRating(ctx context.Context, params MovieDeleteRatingParams) (*MovieDeleteRatingOK, error)
	// MovieDetails invokes movie-details operation.
	//
	// Get the top level details of a movie by ID.
	//
	// GET /3/movie/{movie_id}
	MovieDetails(ctx context.Context, params MovieDetailsParams) (*MovieDetailsOK, error)
	// MovieExternalIds invokes movie-external-ids operation.
	//
	// External IDs.
	//
	// GET /3/movie/{movie_id}/external_ids
	MovieExternalIds(ctx context.Context, params MovieExternalIdsParams) (*MovieExternalIdsOK, error)
	// MovieImages invokes movie-images operation.
	//
	// Get the images that belong to a movie.
	//
	// GET /3/movie/{movie_id}/images
	MovieImages(ctx context.Context, params MovieImagesParams) (*MovieImagesOK, error)
	// MovieKeywords invokes movie-keywords operation.
	//
	// Keywords.
	//
	// GET /3/movie/{movie_id}/keywords
	MovieKeywords(ctx context.Context, params MovieKeywordsParams) (*MovieKeywordsOK, error)
	// MovieLatestID invokes movie-latest-id operation.
	//
	// Get the newest movie ID.
	//
	// GET /3/movie/latest
	MovieLatestID(ctx context.Context) (*MovieLatestIDOK, error)
	// MovieLists invokes movie-lists operation.
	//
	// Lists.
	//
	// GET /3/movie/{movie_id}/lists
	MovieLists(ctx context.Context, params MovieListsParams) (*MovieListsOK, error)
	// MovieNowPlayingList invokes movie-now-playing-list operation.
	//
	// Get a list of movies that are currently in theatres.
	//
	// GET /3/movie/now_playing
	MovieNowPlayingList(ctx context.Context, params MovieNowPlayingListParams) (*MovieNowPlayingListOK, error)
	// MoviePopularList invokes movie-popular-list operation.
	//
	// Get a list of movies ordered by popularity.
	//
	// GET /3/movie/popular
	MoviePopularList(ctx context.Context, params MoviePopularListParams) (*MoviePopularListOK, error)
	// MovieRecommendations invokes movie-recommendations operation.
	//
	// Recommendations.
	//
	// GET /3/movie/{movie_id}/recommendations
	MovieRecommendations(ctx context.Context, params MovieRecommendationsParams) error
	// MovieReleaseDates invokes movie-release-dates operation.
	//
	// Get the release dates and certifications for a movie.
	//
	// GET /3/movie/{movie_id}/release_dates
	MovieReleaseDates(ctx context.Context, params MovieReleaseDatesParams) (*MovieReleaseDatesOK, error)
	// MovieReviews invokes movie-reviews operation.
	//
	// Get the user reviews for a movie.
	//
	// GET /3/movie/{movie_id}/reviews
	MovieReviews(ctx context.Context, params MovieReviewsParams) (*MovieReviewsOK, error)
	// MovieSimilar invokes movie-similar operation.
	//
	// Get the similar movies based on genres and keywords.
	//
	// GET /3/movie/{movie_id}/similar
	MovieSimilar(ctx context.Context, params MovieSimilarParams) (*MovieSimilarOK, error)
	// MovieTopRatedList invokes movie-top-rated-list operation.
	//
	// Get a list of movies ordered by rating.
	//
	// GET /3/movie/top_rated
	MovieTopRatedList(ctx context.Context, params MovieTopRatedListParams) (*MovieTopRatedListOK, error)
	// MovieTranslations invokes movie-translations operation.
	//
	// Get the translations for a movie.
	//
	// GET /3/movie/{movie_id}/translations
	MovieTranslations(ctx context.Context, params MovieTranslationsParams) (*MovieTranslationsOK, error)
	// MovieUpcomingList invokes movie-upcoming-list operation.
	//
	// Get a list of movies that are being released soon.
	//
	// GET /3/movie/upcoming
	MovieUpcomingList(ctx context.Context, params MovieUpcomingListParams) (*MovieUpcomingListOK, error)
	// MovieVideos invokes movie-videos operation.
	//
	// Videos.
	//
	// GET /3/movie/{movie_id}/videos
	MovieVideos(ctx context.Context, params MovieVideosParams) (*MovieVideosOK, error)
	// MovieWatchProviders invokes movie-watch-providers operation.
	//
	// Get the list of streaming providers we have for a movie.
	//
	// GET /3/movie/{movie_id}/watch/providers
	MovieWatchProviders(ctx context.Context, params MovieWatchProvidersParams) (*MovieWatchProvidersOK, error)
	// NetworkDetails invokes network-details operation.
	//
	// Details.
	//
	// GET /3/network/{network_id}
	NetworkDetails(ctx context.Context, params NetworkDetailsParams) (*NetworkDetailsOK, error)
	// PersonChanges invokes person-changes operation.
	//
	// Get the recent changes for a person.
	//
	// GET /3/person/{person_id}/changes
	PersonChanges(ctx context.Context, params PersonChangesParams) (*PersonChangesOK, error)
	// PersonCombinedCredits invokes person-combined-credits operation.
	//
	// Get the combined movie and TV credits that belong to a person.
	//
	// GET /3/person/{person_id}/combined_credits
	PersonCombinedCredits(ctx context.Context, params PersonCombinedCreditsParams) (*PersonCombinedCreditsOK, error)
	// PersonDetails invokes person-details operation.
	//
	// Query the top level details of a person.
	//
	// GET /3/person/{person_id}
	PersonDetails(ctx context.Context, params PersonDetailsParams) (*PersonDetailsOK, error)
	// PersonExternalIds invokes person-external-ids operation.
	//
	// Get the external ID's that belong to a person.
	//
	// GET /3/person/{person_id}/external_ids
	PersonExternalIds(ctx context.Context, params PersonExternalIdsParams) (*PersonExternalIdsOK, error)
	// PersonImages invokes person-images operation.
	//
	// Get the profile images that belong to a person.
	//
	// GET /3/person/{person_id}/images
	PersonImages(ctx context.Context, params PersonImagesParams) error
	// PersonLatestID invokes person-latest-id operation.
	//
	// Get the newest created person. This is a live response and will continuously change.
	//
	// GET /3/person/latest
	PersonLatestID(ctx context.Context) (*PersonLatestIDOK, error)
	// PersonMovieCredits invokes person-movie-credits operation.
	//
	// Get the movie credits for a person.
	//
	// GET /3/person/{person_id}/movie_credits
	PersonMovieCredits(ctx context.Context, params PersonMovieCreditsParams) (*PersonMovieCreditsOK, error)
	// PersonPopularList invokes person-popular-list operation.
	//
	// Get a list of people ordered by popularity.
	//
	// GET /3/person/popular
	PersonPopularList(ctx context.Context, params PersonPopularListParams) (*PersonPopularListOK, error)
	// PersonTaggedImages invokes person-tagged-images operation.
	//
	// Get the tagged images for a person.
	//
	// GET /3/person/{person_id}/tagged_images
	PersonTaggedImages(ctx context.Context, params PersonTaggedImagesParams) (*PersonTaggedImagesOK, error)
	// PersonTvCredits invokes person-tv-credits operation.
	//
	// Get the TV credits that belong to a person.
	//
	// GET /3/person/{person_id}/tv_credits
	PersonTvCredits(ctx context.Context, params PersonTvCreditsParams) (*PersonTvCreditsOK, error)
	// ReviewDetails invokes review-details operation.
	//
	// Retrieve the details of a movie or TV show review.
	//
	// GET /3/review/{review_id}
	ReviewDetails(ctx context.Context, params ReviewDetailsParams) (*ReviewDetailsOK, error)
	// SearchCollection invokes search-collection operation.
	//
	// Search for collections by their original, translated and alternative names.
	//
	// GET /3/search/collection
	SearchCollection(ctx context.Context, params SearchCollectionParams) (*SearchCollectionOK, error)
	// SearchCompany invokes search-company operation.
	//
	// Search for companies by their original and alternative names.
	//
	// GET /3/search/company
	SearchCompany(ctx context.Context, params SearchCompanyParams) (*SearchCompanyOK, error)
	// SearchKeyword invokes search-keyword operation.
	//
	// Search for keywords by their name.
	//
	// GET /3/search/keyword
	SearchKeyword(ctx context.Context, params SearchKeywordParams) (*SearchKeywordOK, error)
	// SearchMovie invokes search-movie operation.
	//
	// Search for movies by their original, translated and alternative titles.
	//
	// GET /3/search/movie
	SearchMovie(ctx context.Context, params SearchMovieParams) (*SearchMovieOK, error)
	// SearchMulti invokes search-multi operation.
	//
	// Use multi search when you want to search for movies, TV shows and people in a single request.
	//
	// GET /3/search/multi
	SearchMulti(ctx context.Context, params SearchMultiParams) (*SearchMultiOK, error)
	// SearchPerson invokes search-person operation.
	//
	// Search for people by their name and also known as names.
	//
	// GET /3/search/person
	SearchPerson(ctx context.Context, params SearchPersonParams) (*SearchPersonOK, error)
	// SearchTv invokes search-tv operation.
	//
	// Search for TV shows by their original, translated and also known as names.
	//
	// GET /3/search/tv
	SearchTv(ctx context.Context, params SearchTvParams) (*SearchTvOK, error)
	// Translations invokes translations operation.
	//
	// Get the translations that belong to a person.
	//
	// GET /3/person/{person_id}/translations
	Translations(ctx context.Context, params TranslationsParams) (*TranslationsOK, error)
	// TrendingAll invokes trending-all operation.
	//
	// Get the trending movies, TV shows and people.
	//
	// GET /3/trending/all/{time_window}
	TrendingAll(ctx context.Context, params TrendingAllParams) (*TrendingAllOK, error)
	// TrendingMovies invokes trending-movies operation.
	//
	// Get the trending movies on TMDB.
	//
	// GET /3/trending/movie/{time_window}
	TrendingMovies(ctx context.Context, params TrendingMoviesParams) (*TrendingMoviesOK, error)
	// TrendingPeople invokes trending-people operation.
	//
	// Get the trending people on TMDB.
	//
	// GET /3/trending/person/{time_window}
	TrendingPeople(ctx context.Context, params TrendingPeopleParams) (*TrendingPeopleOK, error)
	// TrendingTv invokes trending-tv operation.
	//
	// Get the trending TV shows on TMDB.
	//
	// GET /3/trending/tv/{time_window}
	TrendingTv(ctx context.Context, params TrendingTvParams) (*TrendingTvOK, error)
	// TvEpisodeAccountStates invokes tv-episode-account-states operation.
	//
	// Get the rating, watchlist and favourite status.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/account_states
	TvEpisodeAccountStates(ctx context.Context, params TvEpisodeAccountStatesParams) (*TvEpisodeAccountStatesOK, error)
	// TvEpisodeAddRating invokes tv-episode-add-rating operation.
	//
	// Rate a TV episode and save it to your rated list.
	//
	// POST /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating
	TvEpisodeAddRating(ctx context.Context, request OptTvEpisodeAddRatingReq, params TvEpisodeAddRatingParams) (*TvEpisodeAddRatingOK, error)
	// TvEpisodeChangesByID invokes tv-episode-changes-by-id operation.
	//
	// Get the recent changes for a TV episode.
	//
	// GET /3/tv/episode/{episode_id}/changes
	TvEpisodeChangesByID(ctx context.Context, params TvEpisodeChangesByIDParams) (*TvEpisodeChangesByIDOK, error)
	// TvEpisodeCredits invokes tv-episode-credits operation.
	//
	// Credits.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/credits
	TvEpisodeCredits(ctx context.Context, params TvEpisodeCreditsParams) (*TvEpisodeCreditsOK, error)
	// TvEpisodeDeleteRating invokes tv-episode-delete-rating operation.
	//
	// Delete your rating on a TV episode.
	//
	// DELETE /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating
	TvEpisodeDeleteRating(ctx context.Context, params TvEpisodeDeleteRatingParams) (*TvEpisodeDeleteRatingOK, error)
	// TvEpisodeDetails invokes tv-episode-details operation.
	//
	// Query the details of a TV episode.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}
	TvEpisodeDetails(ctx context.Context, params TvEpisodeDetailsParams) (*TvEpisodeDetailsOK, error)
	// TvEpisodeExternalIds invokes tv-episode-external-ids operation.
	//
	// Get a list of external IDs that have been added to a TV episode.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/external_ids
	TvEpisodeExternalIds(ctx context.Context, params TvEpisodeExternalIdsParams) (*TvEpisodeExternalIdsOK, error)
	// TvEpisodeGroupDetails invokes tv-episode-group-details operation.
	//
	// Get the details of a TV episode group.
	//
	// GET /3/tv/episode_group/{tv_episode_group_id}
	TvEpisodeGroupDetails(ctx context.Context, params TvEpisodeGroupDetailsParams) (*TvEpisodeGroupDetailsOK, error)
	// TvEpisodeImages invokes tv-episode-images operation.
	//
	// Get the images that belong to a TV episode.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/images
	TvEpisodeImages(ctx context.Context, params TvEpisodeImagesParams) (*TvEpisodeImagesOK, error)
	// TvEpisodeTranslations invokes tv-episode-translations operation.
	//
	// Get the translations that have been added to a TV episode.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/translations
	TvEpisodeTranslations(ctx context.Context, params TvEpisodeTranslationsParams) (*TvEpisodeTranslationsOK, error)
	// TvEpisodeVideos invokes tv-episode-videos operation.
	//
	// Get the videos that belong to a TV episode.
	//
	// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/videos
	TvEpisodeVideos(ctx context.Context, params TvEpisodeVideosParams) (*TvEpisodeVideosOK, error)
	// TvSeasonAccountStates invokes tv-season-account-states operation.
	//
	// Get the rating, watchlist and favourite status.
	//
	// GET /3/tv/{series_id}/season/{season_number}/account_states
	TvSeasonAccountStates(ctx context.Context, params TvSeasonAccountStatesParams) (*TvSeasonAccountStatesOK, error)
	// TvSeasonAggregateCredits invokes tv-season-aggregate-credits operation.
	//
	// Get the aggregate credits (cast and crew) that have been added to a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/aggregate_credits
	TvSeasonAggregateCredits(ctx context.Context, params TvSeasonAggregateCreditsParams) (*TvSeasonAggregateCreditsOK, error)
	// TvSeasonChangesByID invokes tv-season-changes-by-id operation.
	//
	// Get the recent changes for a TV season.
	//
	// GET /3/tv/season/{season_id}/changes
	TvSeasonChangesByID(ctx context.Context, params TvSeasonChangesByIDParams) (*TvSeasonChangesByIDOK, error)
	// TvSeasonCredits invokes tv-season-credits operation.
	//
	// Credits.
	//
	// GET /3/tv/{series_id}/season/{season_number}/credits
	TvSeasonCredits(ctx context.Context, params TvSeasonCreditsParams) (*TvSeasonCreditsOK, error)
	// TvSeasonDetails invokes tv-season-details operation.
	//
	// Query the details of a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}
	TvSeasonDetails(ctx context.Context, params TvSeasonDetailsParams) (*TvSeasonDetailsOK, error)
	// TvSeasonExternalIds invokes tv-season-external-ids operation.
	//
	// Get a list of external IDs that have been added to a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/external_ids
	TvSeasonExternalIds(ctx context.Context, params TvSeasonExternalIdsParams) (*TvSeasonExternalIdsOK, error)
	// TvSeasonImages invokes tv-season-images operation.
	//
	// Get the images that belong to a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/images
	TvSeasonImages(ctx context.Context, params TvSeasonImagesParams) (*TvSeasonImagesOK, error)
	// TvSeasonTranslations invokes tv-season-translations operation.
	//
	// Get the translations for a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/translations
	TvSeasonTranslations(ctx context.Context, params TvSeasonTranslationsParams) (*TvSeasonTranslationsOK, error)
	// TvSeasonVideos invokes tv-season-videos operation.
	//
	// Get the videos that belong to a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/videos
	TvSeasonVideos(ctx context.Context, params TvSeasonVideosParams) (*TvSeasonVideosOK, error)
	// TvSeasonWatchProviders invokes tv-season-watch-providers operation.
	//
	// Get the list of streaming providers we have for a TV season.
	//
	// GET /3/tv/{series_id}/season/{season_number}/watch/providers
	TvSeasonWatchProviders(ctx context.Context, params TvSeasonWatchProvidersParams) (*TvSeasonWatchProvidersOK, error)
	// TvSeriesAccountStates invokes tv-series-account-states operation.
	//
	// Get the rating, watchlist and favourite status.
	//
	// GET /3/tv/{series_id}/account_states
	TvSeriesAccountStates(ctx context.Context, params TvSeriesAccountStatesParams) (*TvSeriesAccountStatesOK, error)
	// TvSeriesAddRating invokes tv-series-add-rating operation.
	//
	// Rate a TV show and save it to your rated list.
	//
	// POST /3/tv/{series_id}/rating
	TvSeriesAddRating(ctx context.Context, request OptTvSeriesAddRatingReq, params TvSeriesAddRatingParams) (*TvSeriesAddRatingOK, error)
	// TvSeriesAggregateCredits invokes tv-series-aggregate-credits operation.
	//
	// Get the aggregate credits (cast and crew) that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/aggregate_credits
	TvSeriesAggregateCredits(ctx context.Context, params TvSeriesAggregateCreditsParams) (*TvSeriesAggregateCreditsOK, error)
	// TvSeriesAiringTodayList invokes tv-series-airing-today-list operation.
	//
	// Get a list of TV shows airing today.
	//
	// GET /3/tv/airing_today
	TvSeriesAiringTodayList(ctx context.Context, params TvSeriesAiringTodayListParams) (*TvSeriesAiringTodayListOK, error)
	// TvSeriesAlternativeTitles invokes tv-series-alternative-titles operation.
	//
	// Get the alternative titles that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/alternative_titles
	TvSeriesAlternativeTitles(ctx context.Context, params TvSeriesAlternativeTitlesParams) (*TvSeriesAlternativeTitlesOK, error)
	// TvSeriesChanges invokes tv-series-changes operation.
	//
	// Get the recent changes for a TV show.
	//
	// GET /3/tv/{series_id}/changes
	TvSeriesChanges(ctx context.Context, params TvSeriesChangesParams) (*TvSeriesChangesOK, error)
	// TvSeriesContentRatings invokes tv-series-content-ratings operation.
	//
	// Get the content ratings that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/content_ratings
	TvSeriesContentRatings(ctx context.Context, params TvSeriesContentRatingsParams) (*TvSeriesContentRatingsOK, error)
	// TvSeriesCredits invokes tv-series-credits operation.
	//
	// Get the latest season credits of a TV show.
	//
	// GET /3/tv/{series_id}/credits
	TvSeriesCredits(ctx context.Context, params TvSeriesCreditsParams) (*TvSeriesCreditsOK, error)
	// TvSeriesDeleteRating invokes tv-series-delete-rating operation.
	//
	// Delete Rating.
	//
	// DELETE /3/tv/{series_id}/rating
	TvSeriesDeleteRating(ctx context.Context, params TvSeriesDeleteRatingParams) (*TvSeriesDeleteRatingOK, error)
	// TvSeriesDetails invokes tv-series-details operation.
	//
	// Get the details of a TV show.
	//
	// GET /3/tv/{series_id}
	TvSeriesDetails(ctx context.Context, params TvSeriesDetailsParams) (*TvSeriesDetailsOK, error)
	// TvSeriesEpisodeGroups invokes tv-series-episode-groups operation.
	//
	// Get the episode groups that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/episode_groups
	TvSeriesEpisodeGroups(ctx context.Context, params TvSeriesEpisodeGroupsParams) (*TvSeriesEpisodeGroupsOK, error)
	// TvSeriesExternalIds invokes tv-series-external-ids operation.
	//
	// Get a list of external IDs that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/external_ids
	TvSeriesExternalIds(ctx context.Context, params TvSeriesExternalIdsParams) (*TvSeriesExternalIdsOK, error)
	// TvSeriesImages invokes tv-series-images operation.
	//
	// Get the images that belong to a TV series.
	//
	// GET /3/tv/{series_id}/images
	TvSeriesImages(ctx context.Context, params TvSeriesImagesParams) (*TvSeriesImagesOK, error)
	// TvSeriesKeywords invokes tv-series-keywords operation.
	//
	// Get a list of keywords that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/keywords
	TvSeriesKeywords(ctx context.Context, params TvSeriesKeywordsParams) (*TvSeriesKeywordsOK, error)
	// TvSeriesLatestID invokes tv-series-latest-id operation.
	//
	// Get the newest TV show ID.
	//
	// GET /3/tv/latest
	TvSeriesLatestID(ctx context.Context) (*TvSeriesLatestIDOK, error)
	// TvSeriesOnTheAirList invokes tv-series-on-the-air-list operation.
	//
	// Get a list of TV shows that air in the next 7 days.
	//
	// GET /3/tv/on_the_air
	TvSeriesOnTheAirList(ctx context.Context, params TvSeriesOnTheAirListParams) (*TvSeriesOnTheAirListOK, error)
	// TvSeriesPopularList invokes tv-series-popular-list operation.
	//
	// Get a list of TV shows ordered by popularity.
	//
	// GET /3/tv/popular
	TvSeriesPopularList(ctx context.Context, params TvSeriesPopularListParams) (*TvSeriesPopularListOK, error)
	// TvSeriesRecommendations invokes tv-series-recommendations operation.
	//
	// Recommendations.
	//
	// GET /3/tv/{series_id}/recommendations
	TvSeriesRecommendations(ctx context.Context, params TvSeriesRecommendationsParams) (*TvSeriesRecommendationsOK, error)
	// TvSeriesReviews invokes tv-series-reviews operation.
	//
	// Get the reviews that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/reviews
	TvSeriesReviews(ctx context.Context, params TvSeriesReviewsParams) (*TvSeriesReviewsOK, error)
	// TvSeriesScreenedTheatrically invokes tv-series-screened-theatrically operation.
	//
	// Get the seasons and episodes that have screened theatrically.
	//
	// GET /3/tv/{series_id}/screened_theatrically
	TvSeriesScreenedTheatrically(ctx context.Context, params TvSeriesScreenedTheatricallyParams) (*TvSeriesScreenedTheatricallyOK, error)
	// TvSeriesSimilar invokes tv-series-similar operation.
	//
	// Get the similar TV shows.
	//
	// GET /3/tv/{series_id}/similar
	TvSeriesSimilar(ctx context.Context, params TvSeriesSimilarParams) (*TvSeriesSimilarOK, error)
	// TvSeriesTopRatedList invokes tv-series-top-rated-list operation.
	//
	// Get a list of TV shows ordered by rating.
	//
	// GET /3/tv/top_rated
	TvSeriesTopRatedList(ctx context.Context, params TvSeriesTopRatedListParams) (*TvSeriesTopRatedListOK, error)
	// TvSeriesTranslations invokes tv-series-translations operation.
	//
	// Get the translations that have been added to a TV show.
	//
	// GET /3/tv/{series_id}/translations
	TvSeriesTranslations(ctx context.Context, params TvSeriesTranslationsParams) (*TvSeriesTranslationsOK, error)
	// TvSeriesVideos invokes tv-series-videos operation.
	//
	// Get the videos that belong to a TV show.
	//
	// GET /3/tv/{series_id}/videos
	TvSeriesVideos(ctx context.Context, params TvSeriesVideosParams) (*TvSeriesVideosOK, error)
	// TvSeriesWatchProviders invokes tv-series-watch-providers operation.
	//
	// Get the list of streaming providers we have for a TV show.
	//
	// GET /3/tv/{series_id}/watch/providers
	TvSeriesWatchProviders(ctx context.Context, params TvSeriesWatchProvidersParams) (*TvSeriesWatchProvidersOK, error)
	// WatchProviderTvList invokes watch-provider-tv-list operation.
	//
	// Get the list of streaming providers we have for TV shows.
	//
	// GET /3/watch/providers/tv
	WatchProviderTvList(ctx context.Context, params WatchProviderTvListParams) (*WatchProviderTvListOK, error)
	// WatchProvidersAvailableRegions invokes watch-providers-available-regions operation.
	//
	// Get the list of the countries we have watch provider (OTT/streaming) data for.
	//
	// GET /3/watch/providers/regions
	WatchProvidersAvailableRegions(ctx context.Context, params WatchProvidersAvailableRegionsParams) (*WatchProvidersAvailableRegionsOK, error)
	// WatchProvidersMovieList invokes watch-providers-movie-list operation.
	//
	// Get the list of streaming providers we have for movies.
	//
	// GET /3/watch/providers/movie
	WatchProvidersMovieList(ctx context.Context, params WatchProvidersMovieListParams) (*WatchProvidersMovieListOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccountAddFavorite invokes account-add-favorite operation.
//
// Add Favorite.
//
// POST /3/account/{account_id}/favorite
func (c *Client) AccountAddFavorite(ctx context.Context, request OptAccountAddFavoriteReq, params AccountAddFavoriteParams) (*AccountAddFavoriteOK, error) {
	res, err := c.sendAccountAddFavorite(ctx, request, params)
	return res, err
}

func (c *Client) sendAccountAddFavorite(ctx context.Context, request OptAccountAddFavoriteReq, params AccountAddFavoriteParams) (res *AccountAddFavoriteOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/favorite"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountAddFavoriteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountAddFavorite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountAddFavoriteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountAddToWatchlist invokes account-add-to-watchlist operation.
//
// Add To Watchlist.
//
// POST /3/account/{account_id}/watchlist
func (c *Client) AccountAddToWatchlist(ctx context.Context, request OptAccountAddToWatchlistReq, params AccountAddToWatchlistParams) (*AccountAddToWatchlistOK, error) {
	res, err := c.sendAccountAddToWatchlist(ctx, request, params)
	return res, err
}

func (c *Client) sendAccountAddToWatchlist(ctx context.Context, request OptAccountAddToWatchlistReq, params AccountAddToWatchlistParams) (res *AccountAddToWatchlistOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/watchlist"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountAddToWatchlistRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountAddToWatchlist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountAddToWatchlistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountDetails invokes account-details operation.
//
// Details.
//
// GET /3/account/{account_id}
func (c *Client) AccountDetails(ctx context.Context, params AccountDetailsParams) (*AccountDetailsOK, error) {
	res, err := c.sendAccountDetails(ctx, params)
	return res, err
}

func (c *Client) sendAccountDetails(ctx context.Context, params AccountDetailsParams) (res *AccountDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountFavoriteTv invokes account-favorite-tv operation.
//
// Favorite TV.
//
// GET /3/account/{account_id}/favorite/tv
func (c *Client) AccountFavoriteTv(ctx context.Context, params AccountFavoriteTvParams) (*AccountFavoriteTvOK, error) {
	res, err := c.sendAccountFavoriteTv(ctx, params)
	return res, err
}

func (c *Client) sendAccountFavoriteTv(ctx context.Context, params AccountFavoriteTvParams) (res *AccountFavoriteTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/favorite/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountFavoriteTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountFavoriteTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountGetFavorites invokes account-get-favorites operation.
//
// Favorite Movies.
//
// GET /3/account/{account_id}/favorite/movies
func (c *Client) AccountGetFavorites(ctx context.Context, params AccountGetFavoritesParams) (*AccountGetFavoritesOK, error) {
	res, err := c.sendAccountGetFavorites(ctx, params)
	return res, err
}

func (c *Client) sendAccountGetFavorites(ctx context.Context, params AccountGetFavoritesParams) (res *AccountGetFavoritesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/favorite/movies"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountGetFavorites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountGetFavoritesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountLists invokes account-lists operation.
//
// Lists.
//
// GET /3/account/{account_id}/lists
func (c *Client) AccountLists(ctx context.Context, params AccountListsParams) (*AccountListsOK, error) {
	res, err := c.sendAccountLists(ctx, params)
	return res, err
}

func (c *Client) sendAccountLists(ctx context.Context, params AccountListsParams) (res *AccountListsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lists"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountListsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountRatedMovies invokes account-rated-movies operation.
//
// Rated Movies.
//
// GET /3/account/{account_id}/rated/movies
func (c *Client) AccountRatedMovies(ctx context.Context, params AccountRatedMoviesParams) (*AccountRatedMoviesOK, error) {
	res, err := c.sendAccountRatedMovies(ctx, params)
	return res, err
}

func (c *Client) sendAccountRatedMovies(ctx context.Context, params AccountRatedMoviesParams) (res *AccountRatedMoviesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/movies"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountRatedMovies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountRatedMoviesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountRatedTv invokes account-rated-tv operation.
//
// Rated TV.
//
// GET /3/account/{account_id}/rated/tv
func (c *Client) AccountRatedTv(ctx context.Context, params AccountRatedTvParams) (*AccountRatedTvOK, error) {
	res, err := c.sendAccountRatedTv(ctx, params)
	return res, err
}

func (c *Client) sendAccountRatedTv(ctx context.Context, params AccountRatedTvParams) (res *AccountRatedTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountRatedTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountRatedTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountRatedTvEpisodes invokes account-rated-tv-episodes operation.
//
// Rated TV Episodes.
//
// GET /3/account/{account_id}/rated/tv/episodes
func (c *Client) AccountRatedTvEpisodes(ctx context.Context, params AccountRatedTvEpisodesParams) (*AccountRatedTvEpisodesOK, error) {
	res, err := c.sendAccountRatedTvEpisodes(ctx, params)
	return res, err
}

func (c *Client) sendAccountRatedTvEpisodes(ctx context.Context, params AccountRatedTvEpisodesParams) (res *AccountRatedTvEpisodesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/tv/episodes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountRatedTvEpisodes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountRatedTvEpisodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountWatchlistMovies invokes account-watchlist-movies operation.
//
// Watchlist Movies.
//
// GET /3/account/{account_id}/watchlist/movies
func (c *Client) AccountWatchlistMovies(ctx context.Context, params AccountWatchlistMoviesParams) (*AccountWatchlistMoviesOK, error) {
	res, err := c.sendAccountWatchlistMovies(ctx, params)
	return res, err
}

func (c *Client) sendAccountWatchlistMovies(ctx context.Context, params AccountWatchlistMoviesParams) (res *AccountWatchlistMoviesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/watchlist/movies"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountWatchlistMovies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountWatchlistMoviesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountWatchlistTv invokes account-watchlist-tv operation.
//
// Watchlist TV.
//
// GET /3/account/{account_id}/watchlist/tv
func (c *Client) AccountWatchlistTv(ctx context.Context, params AccountWatchlistTvParams) (*AccountWatchlistTvOK, error) {
	res, err := c.sendAccountWatchlistTv(ctx, params)
	return res, err
}

func (c *Client) sendAccountWatchlistTv(ctx context.Context, params AccountWatchlistTvParams) (res *AccountWatchlistTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/account/"
	{
		// Encode "account_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if val, ok := params.AccountID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/watchlist/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AccountWatchlistTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountWatchlistTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AlternativeNamesCopy invokes alternative-names-copy operation.
//
// Get the TV network logos by id.
//
// GET /3/network/{network_id}/images
func (c *Client) AlternativeNamesCopy(ctx context.Context, params AlternativeNamesCopyParams) (*AlternativeNamesCopyOK, error) {
	res, err := c.sendAlternativeNamesCopy(ctx, params)
	return res, err
}

func (c *Client) sendAlternativeNamesCopy(ctx context.Context, params AlternativeNamesCopyParams) (res *AlternativeNamesCopyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/network/"
	{
		// Encode "network_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "network_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.NetworkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AlternativeNamesCopy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAlternativeNamesCopyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationCreateGuestSession invokes authentication-create-guest-session operation.
//
// Create Guest Session.
//
// GET /3/authentication/guest_session/new
func (c *Client) AuthenticationCreateGuestSession(ctx context.Context) (*AuthenticationCreateGuestSessionOK, error) {
	res, err := c.sendAuthenticationCreateGuestSession(ctx)
	return res, err
}

func (c *Client) sendAuthenticationCreateGuestSession(ctx context.Context) (res *AuthenticationCreateGuestSessionOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/guest_session/new"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationCreateGuestSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationCreateGuestSessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationCreateRequestToken invokes authentication-create-request-token operation.
//
// Create Request Token.
//
// GET /3/authentication/token/new
func (c *Client) AuthenticationCreateRequestToken(ctx context.Context) (*AuthenticationCreateRequestTokenOK, error) {
	res, err := c.sendAuthenticationCreateRequestToken(ctx)
	return res, err
}

func (c *Client) sendAuthenticationCreateRequestToken(ctx context.Context) (res *AuthenticationCreateRequestTokenOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/token/new"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationCreateRequestToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationCreateRequestTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationCreateSession invokes authentication-create-session operation.
//
// Create Session.
//
// POST /3/authentication/session/new
func (c *Client) AuthenticationCreateSession(ctx context.Context, request OptAuthenticationCreateSessionReq) (*AuthenticationCreateSessionOK, error) {
	res, err := c.sendAuthenticationCreateSession(ctx, request)
	return res, err
}

func (c *Client) sendAuthenticationCreateSession(ctx context.Context, request OptAuthenticationCreateSessionReq) (res *AuthenticationCreateSessionOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/session/new"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthenticationCreateSessionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationCreateSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationCreateSessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationCreateSessionFromLogin invokes authentication-create-session-from-login operation.
//
// This method allows an application to validate a request token by entering a username and password.
//
// POST /3/authentication/token/validate_with_login
func (c *Client) AuthenticationCreateSessionFromLogin(ctx context.Context, request OptAuthenticationCreateSessionFromLoginReq) (*AuthenticationCreateSessionFromLoginOK, error) {
	res, err := c.sendAuthenticationCreateSessionFromLogin(ctx, request)
	return res, err
}

func (c *Client) sendAuthenticationCreateSessionFromLogin(ctx context.Context, request OptAuthenticationCreateSessionFromLoginReq) (res *AuthenticationCreateSessionFromLoginOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/token/validate_with_login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthenticationCreateSessionFromLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationCreateSessionFromLogin", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationCreateSessionFromLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationCreateSessionFromV4Token invokes authentication-create-session-from-v4-token operation.
//
// Create Session (from v4 token).
//
// POST /3/authentication/session/convert/4
func (c *Client) AuthenticationCreateSessionFromV4Token(ctx context.Context, request OptAuthenticationCreateSessionFromV4TokenReq) (*AuthenticationCreateSessionFromV4TokenOK, error) {
	res, err := c.sendAuthenticationCreateSessionFromV4Token(ctx, request)
	return res, err
}

func (c *Client) sendAuthenticationCreateSessionFromV4Token(ctx context.Context, request OptAuthenticationCreateSessionFromV4TokenReq) (res *AuthenticationCreateSessionFromV4TokenOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/session/convert/4"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthenticationCreateSessionFromV4TokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationCreateSessionFromV4Token", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationCreateSessionFromV4TokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationDeleteSession invokes authentication-delete-session operation.
//
// Delete Session.
//
// DELETE /3/authentication/session
func (c *Client) AuthenticationDeleteSession(ctx context.Context, request OptAuthenticationDeleteSessionReq) (*AuthenticationDeleteSessionOK, error) {
	res, err := c.sendAuthenticationDeleteSession(ctx, request)
	return res, err
}

func (c *Client) sendAuthenticationDeleteSession(ctx context.Context, request OptAuthenticationDeleteSessionReq) (res *AuthenticationDeleteSessionOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthenticationDeleteSessionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationDeleteSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationDeleteSessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthenticationValidateKey invokes authentication-validate-key operation.
//
// Test your API Key to see if it's valid.
//
// GET /3/authentication
func (c *Client) AuthenticationValidateKey(ctx context.Context) (AuthenticationValidateKeyRes, error) {
	res, err := c.sendAuthenticationValidateKey(ctx)
	return res, err
}

func (c *Client) sendAuthenticationValidateKey(ctx context.Context) (res AuthenticationValidateKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/authentication"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "AuthenticationValidateKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthenticationValidateKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificationMovieList invokes certification-movie-list operation.
//
// Get an up to date list of the officially supported movie certifications on TMDB.
//
// GET /3/certification/movie/list
func (c *Client) CertificationMovieList(ctx context.Context) (*CertificationMovieListOK, error) {
	res, err := c.sendCertificationMovieList(ctx)
	return res, err
}

func (c *Client) sendCertificationMovieList(ctx context.Context) (res *CertificationMovieListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/certification/movie/list"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CertificationMovieList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificationMovieListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificationsTvList invokes certifications-tv-list operation.
//
// TV Certifications.
//
// GET /3/certification/tv/list
func (c *Client) CertificationsTvList(ctx context.Context) (*CertificationsTvListOK, error) {
	res, err := c.sendCertificationsTvList(ctx)
	return res, err
}

func (c *Client) sendCertificationsTvList(ctx context.Context) (res *CertificationsTvListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/certification/tv/list"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CertificationsTvList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificationsTvListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangesMovieList invokes changes-movie-list operation.
//
// Get a list of all of the movie ids that have been changed in the past 24 hours.
//
// GET /3/movie/changes
func (c *Client) ChangesMovieList(ctx context.Context, params ChangesMovieListParams) (*ChangesMovieListOK, error) {
	res, err := c.sendChangesMovieList(ctx, params)
	return res, err
}

func (c *Client) sendChangesMovieList(ctx context.Context, params ChangesMovieListParams) (res *ChangesMovieListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ChangesMovieList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangesMovieListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangesPeopleList invokes changes-people-list operation.
//
// People List.
//
// GET /3/person/changes
func (c *Client) ChangesPeopleList(ctx context.Context, params ChangesPeopleListParams) (*ChangesPeopleListOK, error) {
	res, err := c.sendChangesPeopleList(ctx, params)
	return res, err
}

func (c *Client) sendChangesPeopleList(ctx context.Context, params ChangesPeopleListParams) (res *ChangesPeopleListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/person/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ChangesPeopleList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangesPeopleListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangesTvList invokes changes-tv-list operation.
//
// TV List.
//
// GET /3/tv/changes
func (c *Client) ChangesTvList(ctx context.Context, params ChangesTvListParams) (*ChangesTvListOK, error) {
	res, err := c.sendChangesTvList(ctx, params)
	return res, err
}

func (c *Client) sendChangesTvList(ctx context.Context, params ChangesTvListParams) (res *ChangesTvListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ChangesTvList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangesTvListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CollectionDetails invokes collection-details operation.
//
// Get collection details by ID.
//
// GET /3/collection/{collection_id}
func (c *Client) CollectionDetails(ctx context.Context, params CollectionDetailsParams) (*CollectionDetailsOK, error) {
	res, err := c.sendCollectionDetails(ctx, params)
	return res, err
}

func (c *Client) sendCollectionDetails(ctx context.Context, params CollectionDetailsParams) (res *CollectionDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/collection/"
	{
		// Encode "collection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CollectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CollectionDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCollectionDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CollectionImages invokes collection-images operation.
//
// Get the images that belong to a collection.
//
// GET /3/collection/{collection_id}/images
func (c *Client) CollectionImages(ctx context.Context, params CollectionImagesParams) (*CollectionImagesOK, error) {
	res, err := c.sendCollectionImages(ctx, params)
	return res, err
}

func (c *Client) sendCollectionImages(ctx context.Context, params CollectionImagesParams) (res *CollectionImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/collection/"
	{
		// Encode "collection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CollectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_image_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_image_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeImageLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CollectionImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCollectionImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CollectionTranslations invokes collection-translations operation.
//
// Translations.
//
// GET /3/collection/{collection_id}/translations
func (c *Client) CollectionTranslations(ctx context.Context, params CollectionTranslationsParams) (*CollectionTranslationsOK, error) {
	res, err := c.sendCollectionTranslations(ctx, params)
	return res, err
}

func (c *Client) sendCollectionTranslations(ctx context.Context, params CollectionTranslationsParams) (res *CollectionTranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/collection/"
	{
		// Encode "collection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CollectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CollectionTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCollectionTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompanyAlternativeNames invokes company-alternative-names operation.
//
// Get the company details by ID.
//
// GET /3/company/{company_id}/alternative_names
func (c *Client) CompanyAlternativeNames(ctx context.Context, params CompanyAlternativeNamesParams) (*CompanyAlternativeNamesOK, error) {
	res, err := c.sendCompanyAlternativeNames(ctx, params)
	return res, err
}

func (c *Client) sendCompanyAlternativeNames(ctx context.Context, params CompanyAlternativeNamesParams) (res *CompanyAlternativeNamesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/company/"
	{
		// Encode "company_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "company_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CompanyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/alternative_names"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CompanyAlternativeNames", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompanyAlternativeNamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompanyDetails invokes company-details operation.
//
// Get the company details by ID.
//
// GET /3/company/{company_id}
func (c *Client) CompanyDetails(ctx context.Context, params CompanyDetailsParams) (*CompanyDetailsOK, error) {
	res, err := c.sendCompanyDetails(ctx, params)
	return res, err
}

func (c *Client) sendCompanyDetails(ctx context.Context, params CompanyDetailsParams) (res *CompanyDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/company/"
	{
		// Encode "company_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "company_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CompanyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CompanyDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompanyDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompanyImages invokes company-images operation.
//
// Get the company logos by id.
//
// GET /3/company/{company_id}/images
func (c *Client) CompanyImages(ctx context.Context, params CompanyImagesParams) (*CompanyImagesOK, error) {
	res, err := c.sendCompanyImages(ctx, params)
	return res, err
}

func (c *Client) sendCompanyImages(ctx context.Context, params CompanyImagesParams) (res *CompanyImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/company/"
	{
		// Encode "company_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "company_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.CompanyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CompanyImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompanyImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationCountries invokes configuration-countries operation.
//
// Get the list of countries (ISO 3166-1 tags) used throughout TMDB.
//
// GET /3/configuration/countries
func (c *Client) ConfigurationCountries(ctx context.Context, params ConfigurationCountriesParams) ([]ConfigurationCountriesOKItem, error) {
	res, err := c.sendConfigurationCountries(ctx, params)
	return res, err
}

func (c *Client) sendConfigurationCountries(ctx context.Context, params ConfigurationCountriesParams) (res []ConfigurationCountriesOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration/countries"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationCountries", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationCountriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationDetails invokes configuration-details operation.
//
// Query the API configuration details.
//
// GET /3/configuration
func (c *Client) ConfigurationDetails(ctx context.Context) (*ConfigurationDetailsOK, error) {
	res, err := c.sendConfigurationDetails(ctx)
	return res, err
}

func (c *Client) sendConfigurationDetails(ctx context.Context) (res *ConfigurationDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationJobs invokes configuration-jobs operation.
//
// Get the list of the jobs and departments we use on TMDB.
//
// GET /3/configuration/jobs
func (c *Client) ConfigurationJobs(ctx context.Context) ([]ConfigurationJobsOKItem, error) {
	res, err := c.sendConfigurationJobs(ctx)
	return res, err
}

func (c *Client) sendConfigurationJobs(ctx context.Context) (res []ConfigurationJobsOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationLanguages invokes configuration-languages operation.
//
// Get the list of languages (ISO 639-1 tags) used throughout TMDB.
//
// GET /3/configuration/languages
func (c *Client) ConfigurationLanguages(ctx context.Context) ([]ConfigurationLanguagesOKItem, error) {
	res, err := c.sendConfigurationLanguages(ctx)
	return res, err
}

func (c *Client) sendConfigurationLanguages(ctx context.Context) (res []ConfigurationLanguagesOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration/languages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationLanguages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationLanguagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationPrimaryTranslations invokes configuration-primary-translations operation.
//
// Get a list of the officially supported translations on TMDB.
//
// GET /3/configuration/primary_translations
func (c *Client) ConfigurationPrimaryTranslations(ctx context.Context) ([]string, error) {
	res, err := c.sendConfigurationPrimaryTranslations(ctx)
	return res, err
}

func (c *Client) sendConfigurationPrimaryTranslations(ctx context.Context) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration/primary_translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationPrimaryTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationPrimaryTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigurationTimezones invokes configuration-timezones operation.
//
// Get the list of timezones used throughout TMDB.
//
// GET /3/configuration/timezones
func (c *Client) ConfigurationTimezones(ctx context.Context) ([]ConfigurationTimezonesOKItem, error) {
	res, err := c.sendConfigurationTimezones(ctx)
	return res, err
}

func (c *Client) sendConfigurationTimezones(ctx context.Context) (res []ConfigurationTimezonesOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/configuration/timezones"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ConfigurationTimezones", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigurationTimezonesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreditDetails invokes credit-details operation.
//
// Get a movie or TV credit details by ID.
//
// GET /3/credit/{credit_id}
func (c *Client) CreditDetails(ctx context.Context, params CreditDetailsParams) (*CreditDetailsOK, error) {
	res, err := c.sendCreditDetails(ctx, params)
	return res, err
}

func (c *Client) sendCreditDetails(ctx context.Context, params CreditDetailsParams) (res *CreditDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/credit/"
	{
		// Encode "credit_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "credit_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CreditID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "CreditDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreditDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DetailsCopy invokes details-copy operation.
//
// Get the alternative names of a network.
//
// GET /3/network/{network_id}/alternative_names
func (c *Client) DetailsCopy(ctx context.Context, params DetailsCopyParams) (*DetailsCopyOK, error) {
	res, err := c.sendDetailsCopy(ctx, params)
	return res, err
}

func (c *Client) sendDetailsCopy(ctx context.Context, params DetailsCopyParams) (res *DetailsCopyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/network/"
	{
		// Encode "network_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "network_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.NetworkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/alternative_names"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "DetailsCopy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDetailsCopyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DiscoverMovie invokes discover-movie operation.
//
// Find movies using over 30 filters and sort options.
//
// GET /3/discover/movie
func (c *Client) DiscoverMovie(ctx context.Context, params DiscoverMovieParams) (*DiscoverMovieOK, error) {
	res, err := c.sendDiscoverMovie(ctx, params)
	return res, err
}

func (c *Client) sendDiscoverMovie(ctx context.Context, params DiscoverMovieParams) (res *DiscoverMovieOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/discover/movie"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "certification" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "certification",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Certification.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "certification.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "certification.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CertificationGte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "certification.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "certification.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CertificationLte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "certification_country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "certification_country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CertificationCountry.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_video" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_video",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeVideo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "primary_release_year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "primary_release_year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PrimaryReleaseYear.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "primary_release_date.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "primary_release_date.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PrimaryReleaseDateGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "primary_release_date.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "primary_release_date.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PrimaryReleaseDateLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "release_date.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "release_date.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReleaseDateGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "release_date.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "release_date.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReleaseDateLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_average.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_average.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteAverageGte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_average.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_average.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteAverageLte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_count.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_count.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteCountGte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_count.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_count.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteCountLte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "watch_region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "watch_region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WatchRegion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_cast" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_cast",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithCast.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_companies" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_companies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithCompanies.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_crew" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_crew",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithCrew.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_genres" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_genres",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithGenres.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_keywords" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_keywords",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithKeywords.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_origin_country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_origin_country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithOriginCountry.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_original_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_original_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithOriginalLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_people" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_people",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithPeople.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_release_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_release_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithReleaseType.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_runtime.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_runtime.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRuntimeGte.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_runtime.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_runtime.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRuntimeLte.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_watch_monetization_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_watch_monetization_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithWatchMonetizationTypes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_watch_providers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_watch_providers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithWatchProviders.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_companies" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_companies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutCompanies.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_genres" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_genres",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutGenres.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_keywords" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_keywords",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutKeywords.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_watch_providers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_watch_providers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutWatchProviders.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Year.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "DiscoverMovie", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDiscoverMovieResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DiscoverTv invokes discover-tv operation.
//
// Find TV shows using over 30 filters and sort options.
//
// GET /3/discover/tv
func (c *Client) DiscoverTv(ctx context.Context, params DiscoverTvParams) (*DiscoverTvOK, error) {
	res, err := c.sendDiscoverTv(ctx, params)
	return res, err
}

func (c *Client) sendDiscoverTv(ctx context.Context, params DiscoverTvParams) (res *DiscoverTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/discover/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "air_date.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "air_date.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AirDateGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "air_date.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "air_date.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AirDateLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "first_air_date_year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "first_air_date_year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstAirDateYear.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "first_air_date.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "first_air_date.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstAirDateGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "first_air_date.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "first_air_date.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstAirDateLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_null_first_air_dates" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_null_first_air_dates",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeNullFirstAirDates.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "screened_theatrically" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "screened_theatrically",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ScreenedTheatrically.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "timezone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "timezone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Timezone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_average.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_average.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteAverageGte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_average.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_average.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteAverageLte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_count.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_count.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteCountGte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vote_count.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vote_count.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoteCountLte.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "watch_region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "watch_region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WatchRegion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_companies" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_companies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithCompanies.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_genres" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_genres",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithGenres.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_keywords" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_keywords",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithKeywords.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_networks" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_networks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithNetworks.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_origin_country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_origin_country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithOriginCountry.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_original_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_original_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithOriginalLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_runtime.gte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_runtime.gte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRuntimeGte.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_runtime.lte" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_runtime.lte",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRuntimeLte.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_watch_monetization_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_watch_monetization_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithWatchMonetizationTypes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_watch_providers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_watch_providers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithWatchProviders.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_companies" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_companies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutCompanies.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_genres" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_genres",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutGenres.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_keywords" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_keywords",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutKeywords.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "without_watch_providers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "without_watch_providers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithoutWatchProviders.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "DiscoverTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDiscoverTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindByID invokes find-by-id operation.
//
// Find data by external ID's.
//
// GET /3/find/{external_id}
func (c *Client) FindByID(ctx context.Context, params FindByIDParams) (*FindByIDOK, error) {
	res, err := c.sendFindByID(ctx, params)
	return res, err
}

func (c *Client) sendFindByID(ctx context.Context, params FindByIDParams) (res *FindByIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/find/"
	{
		// Encode "external_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "external_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExternalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "external_source" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "external_source",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.ExternalSource)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "FindByID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenreMovieList invokes genre-movie-list operation.
//
// Get the list of official genres for movies.
//
// GET /3/genre/movie/list
func (c *Client) GenreMovieList(ctx context.Context, params GenreMovieListParams) (*GenreMovieListOK, error) {
	res, err := c.sendGenreMovieList(ctx, params)
	return res, err
}

func (c *Client) sendGenreMovieList(ctx context.Context, params GenreMovieListParams) (res *GenreMovieListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/genre/movie/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "GenreMovieList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenreMovieListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenreTvList invokes genre-tv-list operation.
//
// Get the list of official genres for TV shows.
//
// GET /3/genre/tv/list
func (c *Client) GenreTvList(ctx context.Context, params GenreTvListParams) (*GenreTvListOK, error) {
	res, err := c.sendGenreTvList(ctx, params)
	return res, err
}

func (c *Client) sendGenreTvList(ctx context.Context, params GenreTvListParams) (res *GenreTvListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/genre/tv/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "GenreTvList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenreTvListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GuestSessionRatedMovies invokes guest-session-rated-movies operation.
//
// Get the rated movies for a guest session.
//
// GET /3/guest_session/{guest_session_id}/rated/movies
func (c *Client) GuestSessionRatedMovies(ctx context.Context, params GuestSessionRatedMoviesParams) (*GuestSessionRatedMoviesOK, error) {
	res, err := c.sendGuestSessionRatedMovies(ctx, params)
	return res, err
}

func (c *Client) sendGuestSessionRatedMovies(ctx context.Context, params GuestSessionRatedMoviesParams) (res *GuestSessionRatedMoviesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/guest_session/"
	{
		// Encode "guest_session_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guest_session_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GuestSessionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/movies"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "GuestSessionRatedMovies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGuestSessionRatedMoviesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GuestSessionRatedTv invokes guest-session-rated-tv operation.
//
// Get the rated TV shows for a guest session.
//
// GET /3/guest_session/{guest_session_id}/rated/tv
func (c *Client) GuestSessionRatedTv(ctx context.Context, params GuestSessionRatedTvParams) (*GuestSessionRatedTvOK, error) {
	res, err := c.sendGuestSessionRatedTv(ctx, params)
	return res, err
}

func (c *Client) sendGuestSessionRatedTv(ctx context.Context, params GuestSessionRatedTvParams) (res *GuestSessionRatedTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/guest_session/"
	{
		// Encode "guest_session_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guest_session_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GuestSessionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "GuestSessionRatedTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGuestSessionRatedTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GuestSessionRatedTvEpisodes invokes guest-session-rated-tv-episodes operation.
//
// Get the rated TV episodes for a guest session.
//
// GET /3/guest_session/{guest_session_id}/rated/tv/episodes
func (c *Client) GuestSessionRatedTvEpisodes(ctx context.Context, params GuestSessionRatedTvEpisodesParams) (*GuestSessionRatedTvEpisodesOK, error) {
	res, err := c.sendGuestSessionRatedTvEpisodes(ctx, params)
	return res, err
}

func (c *Client) sendGuestSessionRatedTvEpisodes(ctx context.Context, params GuestSessionRatedTvEpisodesParams) (res *GuestSessionRatedTvEpisodesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/guest_session/"
	{
		// Encode "guest_session_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guest_session_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GuestSessionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rated/tv/episodes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "GuestSessionRatedTvEpisodes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGuestSessionRatedTvEpisodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KeywordDetails invokes keyword-details operation.
//
// Details.
//
// GET /3/keyword/{keyword_id}
func (c *Client) KeywordDetails(ctx context.Context, params KeywordDetailsParams) (*KeywordDetailsOK, error) {
	res, err := c.sendKeywordDetails(ctx, params)
	return res, err
}

func (c *Client) sendKeywordDetails(ctx context.Context, params KeywordDetailsParams) (res *KeywordDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/keyword/"
	{
		// Encode "keyword_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "keyword_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.KeywordID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "KeywordDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeKeywordDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KeywordMovies invokes keyword-movies operation.
//
// Movies.
//
// GET /3/keyword/{keyword_id}/movies
func (c *Client) KeywordMovies(ctx context.Context, params KeywordMoviesParams) (*KeywordMoviesOK, error) {
	res, err := c.sendKeywordMovies(ctx, params)
	return res, err
}

func (c *Client) sendKeywordMovies(ctx context.Context, params KeywordMoviesParams) (res *KeywordMoviesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/keyword/"
	{
		// Encode "keyword_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "keyword_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KeywordID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/movies"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "KeywordMovies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeKeywordMoviesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAddMovie invokes list-add-movie operation.
//
// Add a movie to a list.
//
// POST /3/list/{list_id}/add_item
func (c *Client) ListAddMovie(ctx context.Context, request OptListAddMovieReq, params ListAddMovieParams) (*ListAddMovieOK, error) {
	res, err := c.sendListAddMovie(ctx, request, params)
	return res, err
}

func (c *Client) sendListAddMovie(ctx context.Context, request OptListAddMovieReq, params ListAddMovieParams) (res *ListAddMovieOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/add_item"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SessionID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeListAddMovieRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListAddMovie", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAddMovieResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCheckItemStatus invokes list-check-item-status operation.
//
// Use this method to check if an item has already been added to the list.
//
// GET /3/list/{list_id}/item_status
func (c *Client) ListCheckItemStatus(ctx context.Context, params ListCheckItemStatusParams) (*ListCheckItemStatusOK, error) {
	res, err := c.sendListCheckItemStatus(ctx, params)
	return res, err
}

func (c *Client) sendListCheckItemStatus(ctx context.Context, params ListCheckItemStatusParams) (res *ListCheckItemStatusOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/item_status"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "movie_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "movie_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MovieID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListCheckItemStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCheckItemStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListClear invokes list-clear operation.
//
// Clear all items from a list.
//
// POST /3/list/{list_id}/clear
func (c *Client) ListClear(ctx context.Context, params ListClearParams) (*ListClearOK, error) {
	res, err := c.sendListClear(ctx, params)
	return res, err
}

func (c *Client) sendListClear(ctx context.Context, params ListClearParams) (res *ListClearOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clear"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SessionID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "confirm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "confirm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.BoolToString(params.Confirm))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListClear", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListClearResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCreate invokes list-create operation.
//
// Create.
//
// POST /3/list
func (c *Client) ListCreate(ctx context.Context, request OptListCreateReq, params ListCreateParams) (*ListCreateOK, error) {
	res, err := c.sendListCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendListCreate(ctx context.Context, request OptListCreateReq, params ListCreateParams) (res *ListCreateOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SessionID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeListCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDelete invokes list-delete operation.
//
// Delete a list.
//
// DELETE /3/list/{list_id}
func (c *Client) ListDelete(ctx context.Context, params ListDeleteParams) (*ListDeleteOK, error) {
	res, err := c.sendListDelete(ctx, params)
	return res, err
}

func (c *Client) sendListDelete(ctx context.Context, params ListDeleteParams) (res *ListDeleteOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SessionID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDetails invokes list-details operation.
//
// Details.
//
// GET /3/list/{list_id}
func (c *Client) ListDetails(ctx context.Context, params ListDetailsParams) (*ListDetailsOK, error) {
	res, err := c.sendListDetails(ctx, params)
	return res, err
}

func (c *Client) sendListDetails(ctx context.Context, params ListDetailsParams) (res *ListDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRemoveMovie invokes list-remove-movie operation.
//
// Remove a movie from a list.
//
// POST /3/list/{list_id}/remove_item
func (c *Client) ListRemoveMovie(ctx context.Context, request OptListRemoveMovieReq, params ListRemoveMovieParams) (*ListRemoveMovieOK, error) {
	res, err := c.sendListRemoveMovie(ctx, request, params)
	return res, err
}

func (c *Client) sendListRemoveMovie(ctx context.Context, request OptListRemoveMovieReq, params ListRemoveMovieParams) (res *ListRemoveMovieOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/list/"
	{
		// Encode "list_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "list_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ListID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/remove_item"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SessionID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeListRemoveMovieRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ListRemoveMovie", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRemoveMovieResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieAccountStates invokes movie-account-states operation.
//
// Get the rating, watchlist and favourite status of an account.
//
// GET /3/movie/{movie_id}/account_states
func (c *Client) MovieAccountStates(ctx context.Context, params MovieAccountStatesParams) (*MovieAccountStatesOK, error) {
	res, err := c.sendMovieAccountStates(ctx, params)
	return res, err
}

func (c *Client) sendMovieAccountStates(ctx context.Context, params MovieAccountStatesParams) (res *MovieAccountStatesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/account_states"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieAccountStates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieAccountStatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieAddRating invokes movie-add-rating operation.
//
// Rate a movie and save it to your rated list.
//
// POST /3/movie/{movie_id}/rating
func (c *Client) MovieAddRating(ctx context.Context, request OptMovieAddRatingReq, params MovieAddRatingParams) (*MovieAddRatingOK, error) {
	res, err := c.sendMovieAddRating(ctx, request, params)
	return res, err
}

func (c *Client) sendMovieAddRating(ctx context.Context, request OptMovieAddRatingReq, params MovieAddRatingParams) (res *MovieAddRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMovieAddRatingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieAddRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieAddRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieAlternativeTitles invokes movie-alternative-titles operation.
//
// Get the alternative titles for a movie.
//
// GET /3/movie/{movie_id}/alternative_titles
func (c *Client) MovieAlternativeTitles(ctx context.Context, params MovieAlternativeTitlesParams) (*MovieAlternativeTitlesOK, error) {
	res, err := c.sendMovieAlternativeTitles(ctx, params)
	return res, err
}

func (c *Client) sendMovieAlternativeTitles(ctx context.Context, params MovieAlternativeTitlesParams) (res *MovieAlternativeTitlesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/alternative_titles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieAlternativeTitles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieAlternativeTitlesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieChanges invokes movie-changes operation.
//
// Get the recent changes for a movie.
//
// GET /3/movie/{movie_id}/changes
func (c *Client) MovieChanges(ctx context.Context, params MovieChangesParams) (*MovieChangesOK, error) {
	res, err := c.sendMovieChanges(ctx, params)
	return res, err
}

func (c *Client) sendMovieChanges(ctx context.Context, params MovieChangesParams) (res *MovieChangesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieChanges", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieChangesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieCredits invokes movie-credits operation.
//
// Credits.
//
// GET /3/movie/{movie_id}/credits
func (c *Client) MovieCredits(ctx context.Context, params MovieCreditsParams) (*MovieCreditsOK, error) {
	res, err := c.sendMovieCredits(ctx, params)
	return res, err
}

func (c *Client) sendMovieCredits(ctx context.Context, params MovieCreditsParams) (res *MovieCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieDeleteRating invokes movie-delete-rating operation.
//
// Delete a user rating.
//
// DELETE /3/movie/{movie_id}/rating
func (c *Client) MovieDeleteRating(ctx context.Context, params MovieDeleteRatingParams) (*MovieDeleteRatingOK, error) {
	res, err := c.sendMovieDeleteRating(ctx, params)
	return res, err
}

func (c *Client) sendMovieDeleteRating(ctx context.Context, params MovieDeleteRatingParams) (res *MovieDeleteRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieDeleteRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieDeleteRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieDetails invokes movie-details operation.
//
// Get the top level details of a movie by ID.
//
// GET /3/movie/{movie_id}
func (c *Client) MovieDetails(ctx context.Context, params MovieDetailsParams) (*MovieDetailsOK, error) {
	res, err := c.sendMovieDetails(ctx, params)
	return res, err
}

func (c *Client) sendMovieDetails(ctx context.Context, params MovieDetailsParams) (res *MovieDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "append_to_response" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "append_to_response",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppendToResponse.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieExternalIds invokes movie-external-ids operation.
//
// External IDs.
//
// GET /3/movie/{movie_id}/external_ids
func (c *Client) MovieExternalIds(ctx context.Context, params MovieExternalIdsParams) (*MovieExternalIdsOK, error) {
	res, err := c.sendMovieExternalIds(ctx, params)
	return res, err
}

func (c *Client) sendMovieExternalIds(ctx context.Context, params MovieExternalIdsParams) (res *MovieExternalIdsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/external_ids"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieExternalIds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieExternalIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieImages invokes movie-images operation.
//
// Get the images that belong to a movie.
//
// GET /3/movie/{movie_id}/images
func (c *Client) MovieImages(ctx context.Context, params MovieImagesParams) (*MovieImagesOK, error) {
	res, err := c.sendMovieImages(ctx, params)
	return res, err
}

func (c *Client) sendMovieImages(ctx context.Context, params MovieImagesParams) (res *MovieImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_image_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_image_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeImageLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieKeywords invokes movie-keywords operation.
//
// Keywords.
//
// GET /3/movie/{movie_id}/keywords
func (c *Client) MovieKeywords(ctx context.Context, params MovieKeywordsParams) (*MovieKeywordsOK, error) {
	res, err := c.sendMovieKeywords(ctx, params)
	return res, err
}

func (c *Client) sendMovieKeywords(ctx context.Context, params MovieKeywordsParams) (res *MovieKeywordsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keywords"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieKeywords", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieKeywordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieLatestID invokes movie-latest-id operation.
//
// Get the newest movie ID.
//
// GET /3/movie/latest
func (c *Client) MovieLatestID(ctx context.Context) (*MovieLatestIDOK, error) {
	res, err := c.sendMovieLatestID(ctx)
	return res, err
}

func (c *Client) sendMovieLatestID(ctx context.Context) (res *MovieLatestIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/latest"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieLatestID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieLatestIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieLists invokes movie-lists operation.
//
// Lists.
//
// GET /3/movie/{movie_id}/lists
func (c *Client) MovieLists(ctx context.Context, params MovieListsParams) (*MovieListsOK, error) {
	res, err := c.sendMovieLists(ctx, params)
	return res, err
}

func (c *Client) sendMovieLists(ctx context.Context, params MovieListsParams) (res *MovieListsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lists"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieListsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieNowPlayingList invokes movie-now-playing-list operation.
//
// Get a list of movies that are currently in theatres.
//
// GET /3/movie/now_playing
func (c *Client) MovieNowPlayingList(ctx context.Context, params MovieNowPlayingListParams) (*MovieNowPlayingListOK, error) {
	res, err := c.sendMovieNowPlayingList(ctx, params)
	return res, err
}

func (c *Client) sendMovieNowPlayingList(ctx context.Context, params MovieNowPlayingListParams) (res *MovieNowPlayingListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/now_playing"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieNowPlayingList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieNowPlayingListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MoviePopularList invokes movie-popular-list operation.
//
// Get a list of movies ordered by popularity.
//
// GET /3/movie/popular
func (c *Client) MoviePopularList(ctx context.Context, params MoviePopularListParams) (*MoviePopularListOK, error) {
	res, err := c.sendMoviePopularList(ctx, params)
	return res, err
}

func (c *Client) sendMoviePopularList(ctx context.Context, params MoviePopularListParams) (res *MoviePopularListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/popular"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MoviePopularList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMoviePopularListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieRecommendations invokes movie-recommendations operation.
//
// Recommendations.
//
// GET /3/movie/{movie_id}/recommendations
func (c *Client) MovieRecommendations(ctx context.Context, params MovieRecommendationsParams) error {
	_, err := c.sendMovieRecommendations(ctx, params)
	return err
}

func (c *Client) sendMovieRecommendations(ctx context.Context, params MovieRecommendationsParams) (res *MovieRecommendationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recommendations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieRecommendations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieRecommendationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieReleaseDates invokes movie-release-dates operation.
//
// Get the release dates and certifications for a movie.
//
// GET /3/movie/{movie_id}/release_dates
func (c *Client) MovieReleaseDates(ctx context.Context, params MovieReleaseDatesParams) (*MovieReleaseDatesOK, error) {
	res, err := c.sendMovieReleaseDates(ctx, params)
	return res, err
}

func (c *Client) sendMovieReleaseDates(ctx context.Context, params MovieReleaseDatesParams) (res *MovieReleaseDatesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/release_dates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieReleaseDates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieReleaseDatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieReviews invokes movie-reviews operation.
//
// Get the user reviews for a movie.
//
// GET /3/movie/{movie_id}/reviews
func (c *Client) MovieReviews(ctx context.Context, params MovieReviewsParams) (*MovieReviewsOK, error) {
	res, err := c.sendMovieReviews(ctx, params)
	return res, err
}

func (c *Client) sendMovieReviews(ctx context.Context, params MovieReviewsParams) (res *MovieReviewsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reviews"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieReviews", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieReviewsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieSimilar invokes movie-similar operation.
//
// Get the similar movies based on genres and keywords.
//
// GET /3/movie/{movie_id}/similar
func (c *Client) MovieSimilar(ctx context.Context, params MovieSimilarParams) (*MovieSimilarOK, error) {
	res, err := c.sendMovieSimilar(ctx, params)
	return res, err
}

func (c *Client) sendMovieSimilar(ctx context.Context, params MovieSimilarParams) (res *MovieSimilarOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/similar"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieSimilar", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieSimilarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieTopRatedList invokes movie-top-rated-list operation.
//
// Get a list of movies ordered by rating.
//
// GET /3/movie/top_rated
func (c *Client) MovieTopRatedList(ctx context.Context, params MovieTopRatedListParams) (*MovieTopRatedListOK, error) {
	res, err := c.sendMovieTopRatedList(ctx, params)
	return res, err
}

func (c *Client) sendMovieTopRatedList(ctx context.Context, params MovieTopRatedListParams) (res *MovieTopRatedListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/top_rated"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieTopRatedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieTopRatedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieTranslations invokes movie-translations operation.
//
// Get the translations for a movie.
//
// GET /3/movie/{movie_id}/translations
func (c *Client) MovieTranslations(ctx context.Context, params MovieTranslationsParams) (*MovieTranslationsOK, error) {
	res, err := c.sendMovieTranslations(ctx, params)
	return res, err
}

func (c *Client) sendMovieTranslations(ctx context.Context, params MovieTranslationsParams) (res *MovieTranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieUpcomingList invokes movie-upcoming-list operation.
//
// Get a list of movies that are being released soon.
//
// GET /3/movie/upcoming
func (c *Client) MovieUpcomingList(ctx context.Context, params MovieUpcomingListParams) (*MovieUpcomingListOK, error) {
	res, err := c.sendMovieUpcomingList(ctx, params)
	return res, err
}

func (c *Client) sendMovieUpcomingList(ctx context.Context, params MovieUpcomingListParams) (res *MovieUpcomingListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/movie/upcoming"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieUpcomingList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieUpcomingListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieVideos invokes movie-videos operation.
//
// Videos.
//
// GET /3/movie/{movie_id}/videos
func (c *Client) MovieVideos(ctx context.Context, params MovieVideosParams) (*MovieVideosOK, error) {
	res, err := c.sendMovieVideos(ctx, params)
	return res, err
}

func (c *Client) sendMovieVideos(ctx context.Context, params MovieVideosParams) (res *MovieVideosOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/videos"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieVideos", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieVideosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MovieWatchProviders invokes movie-watch-providers operation.
//
// Get the list of streaming providers we have for a movie.
//
// GET /3/movie/{movie_id}/watch/providers
func (c *Client) MovieWatchProviders(ctx context.Context, params MovieWatchProvidersParams) (*MovieWatchProvidersOK, error) {
	res, err := c.sendMovieWatchProviders(ctx, params)
	return res, err
}

func (c *Client) sendMovieWatchProviders(ctx context.Context, params MovieWatchProvidersParams) (res *MovieWatchProvidersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/movie/"
	{
		// Encode "movie_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "movie_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.MovieID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/watch/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "MovieWatchProviders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMovieWatchProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NetworkDetails invokes network-details operation.
//
// Details.
//
// GET /3/network/{network_id}
func (c *Client) NetworkDetails(ctx context.Context, params NetworkDetailsParams) (*NetworkDetailsOK, error) {
	res, err := c.sendNetworkDetails(ctx, params)
	return res, err
}

func (c *Client) sendNetworkDetails(ctx context.Context, params NetworkDetailsParams) (res *NetworkDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/network/"
	{
		// Encode "network_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "network_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.NetworkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "NetworkDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeNetworkDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonChanges invokes person-changes operation.
//
// Get the recent changes for a person.
//
// GET /3/person/{person_id}/changes
func (c *Client) PersonChanges(ctx context.Context, params PersonChangesParams) (*PersonChangesOK, error) {
	res, err := c.sendPersonChanges(ctx, params)
	return res, err
}

func (c *Client) sendPersonChanges(ctx context.Context, params PersonChangesParams) (res *PersonChangesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonChanges", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonChangesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonCombinedCredits invokes person-combined-credits operation.
//
// Get the combined movie and TV credits that belong to a person.
//
// GET /3/person/{person_id}/combined_credits
func (c *Client) PersonCombinedCredits(ctx context.Context, params PersonCombinedCreditsParams) (*PersonCombinedCreditsOK, error) {
	res, err := c.sendPersonCombinedCredits(ctx, params)
	return res, err
}

func (c *Client) sendPersonCombinedCredits(ctx context.Context, params PersonCombinedCreditsParams) (res *PersonCombinedCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/combined_credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonCombinedCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonCombinedCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonDetails invokes person-details operation.
//
// Query the top level details of a person.
//
// GET /3/person/{person_id}
func (c *Client) PersonDetails(ctx context.Context, params PersonDetailsParams) (*PersonDetailsOK, error) {
	res, err := c.sendPersonDetails(ctx, params)
	return res, err
}

func (c *Client) sendPersonDetails(ctx context.Context, params PersonDetailsParams) (res *PersonDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "append_to_response" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "append_to_response",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppendToResponse.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonExternalIds invokes person-external-ids operation.
//
// Get the external ID's that belong to a person.
//
// GET /3/person/{person_id}/external_ids
func (c *Client) PersonExternalIds(ctx context.Context, params PersonExternalIdsParams) (*PersonExternalIdsOK, error) {
	res, err := c.sendPersonExternalIds(ctx, params)
	return res, err
}

func (c *Client) sendPersonExternalIds(ctx context.Context, params PersonExternalIdsParams) (res *PersonExternalIdsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/external_ids"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonExternalIds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonExternalIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonImages invokes person-images operation.
//
// Get the profile images that belong to a person.
//
// GET /3/person/{person_id}/images
func (c *Client) PersonImages(ctx context.Context, params PersonImagesParams) error {
	_, err := c.sendPersonImages(ctx, params)
	return err
}

func (c *Client) sendPersonImages(ctx context.Context, params PersonImagesParams) (res *PersonImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonLatestID invokes person-latest-id operation.
//
// Get the newest created person. This is a live response and will continuously change.
//
// GET /3/person/latest
func (c *Client) PersonLatestID(ctx context.Context) (*PersonLatestIDOK, error) {
	res, err := c.sendPersonLatestID(ctx)
	return res, err
}

func (c *Client) sendPersonLatestID(ctx context.Context) (res *PersonLatestIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/person/latest"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonLatestID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonLatestIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonMovieCredits invokes person-movie-credits operation.
//
// Get the movie credits for a person.
//
// GET /3/person/{person_id}/movie_credits
func (c *Client) PersonMovieCredits(ctx context.Context, params PersonMovieCreditsParams) (*PersonMovieCreditsOK, error) {
	res, err := c.sendPersonMovieCredits(ctx, params)
	return res, err
}

func (c *Client) sendPersonMovieCredits(ctx context.Context, params PersonMovieCreditsParams) (res *PersonMovieCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/movie_credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonMovieCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonMovieCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonPopularList invokes person-popular-list operation.
//
// Get a list of people ordered by popularity.
//
// GET /3/person/popular
func (c *Client) PersonPopularList(ctx context.Context, params PersonPopularListParams) (*PersonPopularListOK, error) {
	res, err := c.sendPersonPopularList(ctx, params)
	return res, err
}

func (c *Client) sendPersonPopularList(ctx context.Context, params PersonPopularListParams) (res *PersonPopularListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/person/popular"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonPopularList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonPopularListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonTaggedImages invokes person-tagged-images operation.
//
// Get the tagged images for a person.
//
// GET /3/person/{person_id}/tagged_images
func (c *Client) PersonTaggedImages(ctx context.Context, params PersonTaggedImagesParams) (*PersonTaggedImagesOK, error) {
	res, err := c.sendPersonTaggedImages(ctx, params)
	return res, err
}

func (c *Client) sendPersonTaggedImages(ctx context.Context, params PersonTaggedImagesParams) (res *PersonTaggedImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tagged_images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonTaggedImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonTaggedImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PersonTvCredits invokes person-tv-credits operation.
//
// Get the TV credits that belong to a person.
//
// GET /3/person/{person_id}/tv_credits
func (c *Client) PersonTvCredits(ctx context.Context, params PersonTvCreditsParams) (*PersonTvCreditsOK, error) {
	res, err := c.sendPersonTvCredits(ctx, params)
	return res, err
}

func (c *Client) sendPersonTvCredits(ctx context.Context, params PersonTvCreditsParams) (res *PersonTvCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tv_credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "PersonTvCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePersonTvCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReviewDetails invokes review-details operation.
//
// Retrieve the details of a movie or TV show review.
//
// GET /3/review/{review_id}
func (c *Client) ReviewDetails(ctx context.Context, params ReviewDetailsParams) (*ReviewDetailsOK, error) {
	res, err := c.sendReviewDetails(ctx, params)
	return res, err
}

func (c *Client) sendReviewDetails(ctx context.Context, params ReviewDetailsParams) (res *ReviewDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/review/"
	{
		// Encode "review_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ReviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "ReviewDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReviewDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCollection invokes search-collection operation.
//
// Search for collections by their original, translated and alternative names.
//
// GET /3/search/collection
func (c *Client) SearchCollection(ctx context.Context, params SearchCollectionParams) (*SearchCollectionOK, error) {
	res, err := c.sendSearchCollection(ctx, params)
	return res, err
}

func (c *Client) sendSearchCollection(ctx context.Context, params SearchCollectionParams) (res *SearchCollectionOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/collection"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchCollection", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCompany invokes search-company operation.
//
// Search for companies by their original and alternative names.
//
// GET /3/search/company
func (c *Client) SearchCompany(ctx context.Context, params SearchCompanyParams) (*SearchCompanyOK, error) {
	res, err := c.sendSearchCompany(ctx, params)
	return res, err
}

func (c *Client) sendSearchCompany(ctx context.Context, params SearchCompanyParams) (res *SearchCompanyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/company"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchCompany", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchCompanyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchKeyword invokes search-keyword operation.
//
// Search for keywords by their name.
//
// GET /3/search/keyword
func (c *Client) SearchKeyword(ctx context.Context, params SearchKeywordParams) (*SearchKeywordOK, error) {
	res, err := c.sendSearchKeyword(ctx, params)
	return res, err
}

func (c *Client) sendSearchKeyword(ctx context.Context, params SearchKeywordParams) (res *SearchKeywordOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/keyword"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchKeyword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchKeywordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchMovie invokes search-movie operation.
//
// Search for movies by their original, translated and alternative titles.
//
// GET /3/search/movie
func (c *Client) SearchMovie(ctx context.Context, params SearchMovieParams) (*SearchMovieOK, error) {
	res, err := c.sendSearchMovie(ctx, params)
	return res, err
}

func (c *Client) sendSearchMovie(ctx context.Context, params SearchMovieParams) (res *SearchMovieOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/movie"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "primary_release_year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "primary_release_year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PrimaryReleaseYear.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Region.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Year.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchMovie", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchMovieResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchMulti invokes search-multi operation.
//
// Use multi search when you want to search for movies, TV shows and people in a single request.
//
// GET /3/search/multi
func (c *Client) SearchMulti(ctx context.Context, params SearchMultiParams) (*SearchMultiOK, error) {
	res, err := c.sendSearchMulti(ctx, params)
	return res, err
}

func (c *Client) sendSearchMulti(ctx context.Context, params SearchMultiParams) (res *SearchMultiOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/multi"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchMulti", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchMultiResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchPerson invokes search-person operation.
//
// Search for people by their name and also known as names.
//
// GET /3/search/person
func (c *Client) SearchPerson(ctx context.Context, params SearchPersonParams) (*SearchPersonOK, error) {
	res, err := c.sendSearchPerson(ctx, params)
	return res, err
}

func (c *Client) sendSearchPerson(ctx context.Context, params SearchPersonParams) (res *SearchPersonOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/person"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchPerson", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchPersonResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchTv invokes search-tv operation.
//
// Search for TV shows by their original, translated and also known as names.
//
// GET /3/search/tv
func (c *Client) SearchTv(ctx context.Context, params SearchTvParams) (*SearchTvOK, error) {
	res, err := c.sendSearchTv(ctx, params)
	return res, err
}

func (c *Client) sendSearchTv(ctx context.Context, params SearchTvParams) (res *SearchTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/search/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "first_air_date_year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "first_air_date_year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstAirDateYear.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_adult" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_adult",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAdult.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "year" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "year",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Year.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "SearchTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Translations invokes translations operation.
//
// Get the translations that belong to a person.
//
// GET /3/person/{person_id}/translations
func (c *Client) Translations(ctx context.Context, params TranslationsParams) (*TranslationsOK, error) {
	res, err := c.sendTranslations(ctx, params)
	return res, err
}

func (c *Client) sendTranslations(ctx context.Context, params TranslationsParams) (res *TranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/person/"
	{
		// Encode "person_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "person_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.PersonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "Translations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TrendingAll invokes trending-all operation.
//
// Get the trending movies, TV shows and people.
//
// GET /3/trending/all/{time_window}
func (c *Client) TrendingAll(ctx context.Context, params TrendingAllParams) (*TrendingAllOK, error) {
	res, err := c.sendTrendingAll(ctx, params)
	return res, err
}

func (c *Client) sendTrendingAll(ctx context.Context, params TrendingAllParams) (res *TrendingAllOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/trending/all/"
	{
		// Encode "time_window" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "time_window",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TimeWindow)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TrendingAll", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTrendingAllResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TrendingMovies invokes trending-movies operation.
//
// Get the trending movies on TMDB.
//
// GET /3/trending/movie/{time_window}
func (c *Client) TrendingMovies(ctx context.Context, params TrendingMoviesParams) (*TrendingMoviesOK, error) {
	res, err := c.sendTrendingMovies(ctx, params)
	return res, err
}

func (c *Client) sendTrendingMovies(ctx context.Context, params TrendingMoviesParams) (res *TrendingMoviesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/trending/movie/"
	{
		// Encode "time_window" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "time_window",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TimeWindow)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TrendingMovies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTrendingMoviesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TrendingPeople invokes trending-people operation.
//
// Get the trending people on TMDB.
//
// GET /3/trending/person/{time_window}
func (c *Client) TrendingPeople(ctx context.Context, params TrendingPeopleParams) (*TrendingPeopleOK, error) {
	res, err := c.sendTrendingPeople(ctx, params)
	return res, err
}

func (c *Client) sendTrendingPeople(ctx context.Context, params TrendingPeopleParams) (res *TrendingPeopleOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/trending/person/"
	{
		// Encode "time_window" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "time_window",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TimeWindow)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TrendingPeople", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTrendingPeopleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TrendingTv invokes trending-tv operation.
//
// Get the trending TV shows on TMDB.
//
// GET /3/trending/tv/{time_window}
func (c *Client) TrendingTv(ctx context.Context, params TrendingTvParams) (*TrendingTvOK, error) {
	res, err := c.sendTrendingTv(ctx, params)
	return res, err
}

func (c *Client) sendTrendingTv(ctx context.Context, params TrendingTvParams) (res *TrendingTvOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/trending/tv/"
	{
		// Encode "time_window" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "time_window",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TimeWindow)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TrendingTv", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTrendingTvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeAccountStates invokes tv-episode-account-states operation.
//
// Get the rating, watchlist and favourite status.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/account_states
func (c *Client) TvEpisodeAccountStates(ctx context.Context, params TvEpisodeAccountStatesParams) (*TvEpisodeAccountStatesOK, error) {
	res, err := c.sendTvEpisodeAccountStates(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeAccountStates(ctx context.Context, params TvEpisodeAccountStatesParams) (res *TvEpisodeAccountStatesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/account_states"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeAccountStates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeAccountStatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeAddRating invokes tv-episode-add-rating operation.
//
// Rate a TV episode and save it to your rated list.
//
// POST /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating
func (c *Client) TvEpisodeAddRating(ctx context.Context, request OptTvEpisodeAddRatingReq, params TvEpisodeAddRatingParams) (*TvEpisodeAddRatingOK, error) {
	res, err := c.sendTvEpisodeAddRating(ctx, request, params)
	return res, err
}

func (c *Client) sendTvEpisodeAddRating(ctx context.Context, request OptTvEpisodeAddRatingReq, params TvEpisodeAddRatingParams) (res *TvEpisodeAddRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTvEpisodeAddRatingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeAddRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeAddRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeChangesByID invokes tv-episode-changes-by-id operation.
//
// Get the recent changes for a TV episode.
//
// GET /3/tv/episode/{episode_id}/changes
func (c *Client) TvEpisodeChangesByID(ctx context.Context, params TvEpisodeChangesByIDParams) (*TvEpisodeChangesByIDOK, error) {
	res, err := c.sendTvEpisodeChangesByID(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeChangesByID(ctx context.Context, params TvEpisodeChangesByIDParams) (res *TvEpisodeChangesByIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/episode/"
	{
		// Encode "episode_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/changes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeChangesByID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeChangesByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeCredits invokes tv-episode-credits operation.
//
// Credits.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/credits
func (c *Client) TvEpisodeCredits(ctx context.Context, params TvEpisodeCreditsParams) (*TvEpisodeCreditsOK, error) {
	res, err := c.sendTvEpisodeCredits(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeCredits(ctx context.Context, params TvEpisodeCreditsParams) (res *TvEpisodeCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeDeleteRating invokes tv-episode-delete-rating operation.
//
// Delete your rating on a TV episode.
//
// DELETE /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating
func (c *Client) TvEpisodeDeleteRating(ctx context.Context, params TvEpisodeDeleteRatingParams) (*TvEpisodeDeleteRatingOK, error) {
	res, err := c.sendTvEpisodeDeleteRating(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeDeleteRating(ctx context.Context, params TvEpisodeDeleteRatingParams) (res *TvEpisodeDeleteRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeDeleteRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeDeleteRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeDetails invokes tv-episode-details operation.
//
// Query the details of a TV episode.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}
func (c *Client) TvEpisodeDetails(ctx context.Context, params TvEpisodeDetailsParams) (*TvEpisodeDetailsOK, error) {
	res, err := c.sendTvEpisodeDetails(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeDetails(ctx context.Context, params TvEpisodeDetailsParams) (res *TvEpisodeDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "append_to_response" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "append_to_response",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppendToResponse.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeExternalIds invokes tv-episode-external-ids operation.
//
// Get a list of external IDs that have been added to a TV episode.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/external_ids
func (c *Client) TvEpisodeExternalIds(ctx context.Context, params TvEpisodeExternalIdsParams) (*TvEpisodeExternalIdsOK, error) {
	res, err := c.sendTvEpisodeExternalIds(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeExternalIds(ctx context.Context, params TvEpisodeExternalIdsParams) (res *TvEpisodeExternalIdsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/external_ids"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeExternalIds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeExternalIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeGroupDetails invokes tv-episode-group-details operation.
//
// Get the details of a TV episode group.
//
// GET /3/tv/episode_group/{tv_episode_group_id}
func (c *Client) TvEpisodeGroupDetails(ctx context.Context, params TvEpisodeGroupDetailsParams) (*TvEpisodeGroupDetailsOK, error) {
	res, err := c.sendTvEpisodeGroupDetails(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeGroupDetails(ctx context.Context, params TvEpisodeGroupDetailsParams) (res *TvEpisodeGroupDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/tv/episode_group/"
	{
		// Encode "tv_episode_group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tv_episode_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TvEpisodeGroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeGroupDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeGroupDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeImages invokes tv-episode-images operation.
//
// Get the images that belong to a TV episode.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/images
func (c *Client) TvEpisodeImages(ctx context.Context, params TvEpisodeImagesParams) (*TvEpisodeImagesOK, error) {
	res, err := c.sendTvEpisodeImages(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeImages(ctx context.Context, params TvEpisodeImagesParams) (res *TvEpisodeImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_image_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_image_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeImageLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeTranslations invokes tv-episode-translations operation.
//
// Get the translations that have been added to a TV episode.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/translations
func (c *Client) TvEpisodeTranslations(ctx context.Context, params TvEpisodeTranslationsParams) (*TvEpisodeTranslationsOK, error) {
	res, err := c.sendTvEpisodeTranslations(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeTranslations(ctx context.Context, params TvEpisodeTranslationsParams) (res *TvEpisodeTranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvEpisodeVideos invokes tv-episode-videos operation.
//
// Get the videos that belong to a TV episode.
//
// GET /3/tv/{series_id}/season/{season_number}/episode/{episode_number}/videos
func (c *Client) TvEpisodeVideos(ctx context.Context, params TvEpisodeVideosParams) (*TvEpisodeVideosOK, error) {
	res, err := c.sendTvEpisodeVideos(ctx, params)
	return res, err
}

func (c *Client) sendTvEpisodeVideos(ctx context.Context, params TvEpisodeVideosParams) (res *TvEpisodeVideosOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/episode/"
	{
		// Encode "episode_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "episode_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.EpisodeNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/videos"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_video_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_video_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeVideoLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvEpisodeVideos", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvEpisodeVideosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonAccountStates invokes tv-season-account-states operation.
//
// Get the rating, watchlist and favourite status.
//
// GET /3/tv/{series_id}/season/{season_number}/account_states
func (c *Client) TvSeasonAccountStates(ctx context.Context, params TvSeasonAccountStatesParams) (*TvSeasonAccountStatesOK, error) {
	res, err := c.sendTvSeasonAccountStates(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonAccountStates(ctx context.Context, params TvSeasonAccountStatesParams) (res *TvSeasonAccountStatesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/account_states"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonAccountStates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonAccountStatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonAggregateCredits invokes tv-season-aggregate-credits operation.
//
// Get the aggregate credits (cast and crew) that have been added to a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/aggregate_credits
func (c *Client) TvSeasonAggregateCredits(ctx context.Context, params TvSeasonAggregateCreditsParams) (*TvSeasonAggregateCreditsOK, error) {
	res, err := c.sendTvSeasonAggregateCredits(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonAggregateCredits(ctx context.Context, params TvSeasonAggregateCreditsParams) (res *TvSeasonAggregateCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/aggregate_credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonAggregateCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonAggregateCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonChangesByID invokes tv-season-changes-by-id operation.
//
// Get the recent changes for a TV season.
//
// GET /3/tv/season/{season_id}/changes
func (c *Client) TvSeasonChangesByID(ctx context.Context, params TvSeasonChangesByIDParams) (*TvSeasonChangesByIDOK, error) {
	res, err := c.sendTvSeasonChangesByID(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonChangesByID(ctx context.Context, params TvSeasonChangesByIDParams) (res *TvSeasonChangesByIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/season/"
	{
		// Encode "season_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonChangesByID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonChangesByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonCredits invokes tv-season-credits operation.
//
// Credits.
//
// GET /3/tv/{series_id}/season/{season_number}/credits
func (c *Client) TvSeasonCredits(ctx context.Context, params TvSeasonCreditsParams) (*TvSeasonCreditsOK, error) {
	res, err := c.sendTvSeasonCredits(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonCredits(ctx context.Context, params TvSeasonCreditsParams) (res *TvSeasonCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonDetails invokes tv-season-details operation.
//
// Query the details of a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}
func (c *Client) TvSeasonDetails(ctx context.Context, params TvSeasonDetailsParams) (*TvSeasonDetailsOK, error) {
	res, err := c.sendTvSeasonDetails(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonDetails(ctx context.Context, params TvSeasonDetailsParams) (res *TvSeasonDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "append_to_response" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "append_to_response",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppendToResponse.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonExternalIds invokes tv-season-external-ids operation.
//
// Get a list of external IDs that have been added to a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/external_ids
func (c *Client) TvSeasonExternalIds(ctx context.Context, params TvSeasonExternalIdsParams) (*TvSeasonExternalIdsOK, error) {
	res, err := c.sendTvSeasonExternalIds(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonExternalIds(ctx context.Context, params TvSeasonExternalIdsParams) (res *TvSeasonExternalIdsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/external_ids"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonExternalIds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonExternalIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonImages invokes tv-season-images operation.
//
// Get the images that belong to a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/images
func (c *Client) TvSeasonImages(ctx context.Context, params TvSeasonImagesParams) (*TvSeasonImagesOK, error) {
	res, err := c.sendTvSeasonImages(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonImages(ctx context.Context, params TvSeasonImagesParams) (res *TvSeasonImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_image_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_image_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeImageLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonTranslations invokes tv-season-translations operation.
//
// Get the translations for a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/translations
func (c *Client) TvSeasonTranslations(ctx context.Context, params TvSeasonTranslationsParams) (*TvSeasonTranslationsOK, error) {
	res, err := c.sendTvSeasonTranslations(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonTranslations(ctx context.Context, params TvSeasonTranslationsParams) (res *TvSeasonTranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonVideos invokes tv-season-videos operation.
//
// Get the videos that belong to a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/videos
func (c *Client) TvSeasonVideos(ctx context.Context, params TvSeasonVideosParams) (*TvSeasonVideosOK, error) {
	res, err := c.sendTvSeasonVideos(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonVideos(ctx context.Context, params TvSeasonVideosParams) (res *TvSeasonVideosOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/videos"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_video_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_video_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeVideoLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonVideos", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonVideosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeasonWatchProviders invokes tv-season-watch-providers operation.
//
// Get the list of streaming providers we have for a TV season.
//
// GET /3/tv/{series_id}/season/{season_number}/watch/providers
func (c *Client) TvSeasonWatchProviders(ctx context.Context, params TvSeasonWatchProvidersParams) (*TvSeasonWatchProvidersOK, error) {
	res, err := c.sendTvSeasonWatchProviders(ctx, params)
	return res, err
}

func (c *Client) sendTvSeasonWatchProviders(ctx context.Context, params TvSeasonWatchProvidersParams) (res *TvSeasonWatchProvidersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/season/"
	{
		// Encode "season_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "season_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeasonNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/watch/providers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeasonWatchProviders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeasonWatchProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesAccountStates invokes tv-series-account-states operation.
//
// Get the rating, watchlist and favourite status.
//
// GET /3/tv/{series_id}/account_states
func (c *Client) TvSeriesAccountStates(ctx context.Context, params TvSeriesAccountStatesParams) (*TvSeriesAccountStatesOK, error) {
	res, err := c.sendTvSeriesAccountStates(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesAccountStates(ctx context.Context, params TvSeriesAccountStatesParams) (res *TvSeriesAccountStatesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/account_states"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesAccountStates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesAccountStatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesAddRating invokes tv-series-add-rating operation.
//
// Rate a TV show and save it to your rated list.
//
// POST /3/tv/{series_id}/rating
func (c *Client) TvSeriesAddRating(ctx context.Context, request OptTvSeriesAddRatingReq, params TvSeriesAddRatingParams) (*TvSeriesAddRatingOK, error) {
	res, err := c.sendTvSeriesAddRating(ctx, request, params)
	return res, err
}

func (c *Client) sendTvSeriesAddRating(ctx context.Context, request OptTvSeriesAddRatingReq, params TvSeriesAddRatingParams) (res *TvSeriesAddRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTvSeriesAddRatingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesAddRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesAddRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesAggregateCredits invokes tv-series-aggregate-credits operation.
//
// Get the aggregate credits (cast and crew) that have been added to a TV show.
//
// GET /3/tv/{series_id}/aggregate_credits
func (c *Client) TvSeriesAggregateCredits(ctx context.Context, params TvSeriesAggregateCreditsParams) (*TvSeriesAggregateCreditsOK, error) {
	res, err := c.sendTvSeriesAggregateCredits(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesAggregateCredits(ctx context.Context, params TvSeriesAggregateCreditsParams) (res *TvSeriesAggregateCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/aggregate_credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesAggregateCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesAggregateCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesAiringTodayList invokes tv-series-airing-today-list operation.
//
// Get a list of TV shows airing today.
//
// GET /3/tv/airing_today
func (c *Client) TvSeriesAiringTodayList(ctx context.Context, params TvSeriesAiringTodayListParams) (*TvSeriesAiringTodayListOK, error) {
	res, err := c.sendTvSeriesAiringTodayList(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesAiringTodayList(ctx context.Context, params TvSeriesAiringTodayListParams) (res *TvSeriesAiringTodayListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/airing_today"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "timezone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "timezone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Timezone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesAiringTodayList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesAiringTodayListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesAlternativeTitles invokes tv-series-alternative-titles operation.
//
// Get the alternative titles that have been added to a TV show.
//
// GET /3/tv/{series_id}/alternative_titles
func (c *Client) TvSeriesAlternativeTitles(ctx context.Context, params TvSeriesAlternativeTitlesParams) (*TvSeriesAlternativeTitlesOK, error) {
	res, err := c.sendTvSeriesAlternativeTitles(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesAlternativeTitles(ctx context.Context, params TvSeriesAlternativeTitlesParams) (res *TvSeriesAlternativeTitlesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/alternative_titles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesAlternativeTitles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesAlternativeTitlesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesChanges invokes tv-series-changes operation.
//
// Get the recent changes for a TV show.
//
// GET /3/tv/{series_id}/changes
func (c *Client) TvSeriesChanges(ctx context.Context, params TvSeriesChangesParams) (*TvSeriesChangesOK, error) {
	res, err := c.sendTvSeriesChanges(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesChanges(ctx context.Context, params TvSeriesChangesParams) (res *TvSeriesChangesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/changes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesChanges", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesChangesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesContentRatings invokes tv-series-content-ratings operation.
//
// Get the content ratings that have been added to a TV show.
//
// GET /3/tv/{series_id}/content_ratings
func (c *Client) TvSeriesContentRatings(ctx context.Context, params TvSeriesContentRatingsParams) (*TvSeriesContentRatingsOK, error) {
	res, err := c.sendTvSeriesContentRatings(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesContentRatings(ctx context.Context, params TvSeriesContentRatingsParams) (res *TvSeriesContentRatingsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content_ratings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesContentRatings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesContentRatingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesCredits invokes tv-series-credits operation.
//
// Get the latest season credits of a TV show.
//
// GET /3/tv/{series_id}/credits
func (c *Client) TvSeriesCredits(ctx context.Context, params TvSeriesCreditsParams) (*TvSeriesCreditsOK, error) {
	res, err := c.sendTvSeriesCredits(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesCredits(ctx context.Context, params TvSeriesCreditsParams) (res *TvSeriesCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesDeleteRating invokes tv-series-delete-rating operation.
//
// Delete Rating.
//
// DELETE /3/tv/{series_id}/rating
func (c *Client) TvSeriesDeleteRating(ctx context.Context, params TvSeriesDeleteRatingParams) (*TvSeriesDeleteRatingOK, error) {
	res, err := c.sendTvSeriesDeleteRating(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesDeleteRating(ctx context.Context, params TvSeriesDeleteRatingParams) (res *TvSeriesDeleteRatingOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rating"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "guest_session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "guest_session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GuestSessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesDeleteRating", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesDeleteRatingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesDetails invokes tv-series-details operation.
//
// Get the details of a TV show.
//
// GET /3/tv/{series_id}
func (c *Client) TvSeriesDetails(ctx context.Context, params TvSeriesDetailsParams) (*TvSeriesDetailsOK, error) {
	res, err := c.sendTvSeriesDetails(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesDetails(ctx context.Context, params TvSeriesDetailsParams) (res *TvSeriesDetailsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "append_to_response" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "append_to_response",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AppendToResponse.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesEpisodeGroups invokes tv-series-episode-groups operation.
//
// Get the episode groups that have been added to a TV show.
//
// GET /3/tv/{series_id}/episode_groups
func (c *Client) TvSeriesEpisodeGroups(ctx context.Context, params TvSeriesEpisodeGroupsParams) (*TvSeriesEpisodeGroupsOK, error) {
	res, err := c.sendTvSeriesEpisodeGroups(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesEpisodeGroups(ctx context.Context, params TvSeriesEpisodeGroupsParams) (res *TvSeriesEpisodeGroupsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/episode_groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesEpisodeGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesEpisodeGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesExternalIds invokes tv-series-external-ids operation.
//
// Get a list of external IDs that have been added to a TV show.
//
// GET /3/tv/{series_id}/external_ids
func (c *Client) TvSeriesExternalIds(ctx context.Context, params TvSeriesExternalIdsParams) (*TvSeriesExternalIdsOK, error) {
	res, err := c.sendTvSeriesExternalIds(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesExternalIds(ctx context.Context, params TvSeriesExternalIdsParams) (res *TvSeriesExternalIdsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/external_ids"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesExternalIds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesExternalIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesImages invokes tv-series-images operation.
//
// Get the images that belong to a TV series.
//
// GET /3/tv/{series_id}/images
func (c *Client) TvSeriesImages(ctx context.Context, params TvSeriesImagesParams) (*TvSeriesImagesOK, error) {
	res, err := c.sendTvSeriesImages(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesImages(ctx context.Context, params TvSeriesImagesParams) (res *TvSeriesImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_image_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_image_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeImageLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesKeywords invokes tv-series-keywords operation.
//
// Get a list of keywords that have been added to a TV show.
//
// GET /3/tv/{series_id}/keywords
func (c *Client) TvSeriesKeywords(ctx context.Context, params TvSeriesKeywordsParams) (*TvSeriesKeywordsOK, error) {
	res, err := c.sendTvSeriesKeywords(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesKeywords(ctx context.Context, params TvSeriesKeywordsParams) (res *TvSeriesKeywordsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keywords"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesKeywords", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesKeywordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesLatestID invokes tv-series-latest-id operation.
//
// Get the newest TV show ID.
//
// GET /3/tv/latest
func (c *Client) TvSeriesLatestID(ctx context.Context) (*TvSeriesLatestIDOK, error) {
	res, err := c.sendTvSeriesLatestID(ctx)
	return res, err
}

func (c *Client) sendTvSeriesLatestID(ctx context.Context) (res *TvSeriesLatestIDOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/latest"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesLatestID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesLatestIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesOnTheAirList invokes tv-series-on-the-air-list operation.
//
// Get a list of TV shows that air in the next 7 days.
//
// GET /3/tv/on_the_air
func (c *Client) TvSeriesOnTheAirList(ctx context.Context, params TvSeriesOnTheAirListParams) (*TvSeriesOnTheAirListOK, error) {
	res, err := c.sendTvSeriesOnTheAirList(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesOnTheAirList(ctx context.Context, params TvSeriesOnTheAirListParams) (res *TvSeriesOnTheAirListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/on_the_air"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "timezone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "timezone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Timezone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesOnTheAirList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesOnTheAirListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesPopularList invokes tv-series-popular-list operation.
//
// Get a list of TV shows ordered by popularity.
//
// GET /3/tv/popular
func (c *Client) TvSeriesPopularList(ctx context.Context, params TvSeriesPopularListParams) (*TvSeriesPopularListOK, error) {
	res, err := c.sendTvSeriesPopularList(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesPopularList(ctx context.Context, params TvSeriesPopularListParams) (res *TvSeriesPopularListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/popular"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesPopularList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesPopularListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesRecommendations invokes tv-series-recommendations operation.
//
// Recommendations.
//
// GET /3/tv/{series_id}/recommendations
func (c *Client) TvSeriesRecommendations(ctx context.Context, params TvSeriesRecommendationsParams) (*TvSeriesRecommendationsOK, error) {
	res, err := c.sendTvSeriesRecommendations(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesRecommendations(ctx context.Context, params TvSeriesRecommendationsParams) (res *TvSeriesRecommendationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recommendations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesRecommendations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesRecommendationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesReviews invokes tv-series-reviews operation.
//
// Get the reviews that have been added to a TV show.
//
// GET /3/tv/{series_id}/reviews
func (c *Client) TvSeriesReviews(ctx context.Context, params TvSeriesReviewsParams) (*TvSeriesReviewsOK, error) {
	res, err := c.sendTvSeriesReviews(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesReviews(ctx context.Context, params TvSeriesReviewsParams) (res *TvSeriesReviewsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reviews"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesReviews", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesReviewsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesScreenedTheatrically invokes tv-series-screened-theatrically operation.
//
// Get the seasons and episodes that have screened theatrically.
//
// GET /3/tv/{series_id}/screened_theatrically
func (c *Client) TvSeriesScreenedTheatrically(ctx context.Context, params TvSeriesScreenedTheatricallyParams) (*TvSeriesScreenedTheatricallyOK, error) {
	res, err := c.sendTvSeriesScreenedTheatrically(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesScreenedTheatrically(ctx context.Context, params TvSeriesScreenedTheatricallyParams) (res *TvSeriesScreenedTheatricallyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/screened_theatrically"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesScreenedTheatrically", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesScreenedTheatricallyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesSimilar invokes tv-series-similar operation.
//
// Get the similar TV shows.
//
// GET /3/tv/{series_id}/similar
func (c *Client) TvSeriesSimilar(ctx context.Context, params TvSeriesSimilarParams) (*TvSeriesSimilarOK, error) {
	res, err := c.sendTvSeriesSimilar(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesSimilar(ctx context.Context, params TvSeriesSimilarParams) (res *TvSeriesSimilarOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/similar"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesSimilar", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesSimilarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesTopRatedList invokes tv-series-top-rated-list operation.
//
// Get a list of TV shows ordered by rating.
//
// GET /3/tv/top_rated
func (c *Client) TvSeriesTopRatedList(ctx context.Context, params TvSeriesTopRatedListParams) (*TvSeriesTopRatedListOK, error) {
	res, err := c.sendTvSeriesTopRatedList(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesTopRatedList(ctx context.Context, params TvSeriesTopRatedListParams) (res *TvSeriesTopRatedListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/tv/top_rated"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesTopRatedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesTopRatedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesTranslations invokes tv-series-translations operation.
//
// Get the translations that have been added to a TV show.
//
// GET /3/tv/{series_id}/translations
func (c *Client) TvSeriesTranslations(ctx context.Context, params TvSeriesTranslationsParams) (*TvSeriesTranslationsOK, error) {
	res, err := c.sendTvSeriesTranslations(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesTranslations(ctx context.Context, params TvSeriesTranslationsParams) (res *TvSeriesTranslationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/translations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesTranslations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesTranslationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesVideos invokes tv-series-videos operation.
//
// Get the videos that belong to a TV show.
//
// GET /3/tv/{series_id}/videos
func (c *Client) TvSeriesVideos(ctx context.Context, params TvSeriesVideosParams) (*TvSeriesVideosOK, error) {
	res, err := c.sendTvSeriesVideos(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesVideos(ctx context.Context, params TvSeriesVideosParams) (res *TvSeriesVideosOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/videos"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include_video_language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_video_language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeVideoLanguage.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesVideos", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesVideosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TvSeriesWatchProviders invokes tv-series-watch-providers operation.
//
// Get the list of streaming providers we have for a TV show.
//
// GET /3/tv/{series_id}/watch/providers
func (c *Client) TvSeriesWatchProviders(ctx context.Context, params TvSeriesWatchProvidersParams) (*TvSeriesWatchProvidersOK, error) {
	res, err := c.sendTvSeriesWatchProviders(ctx, params)
	return res, err
}

func (c *Client) sendTvSeriesWatchProviders(ctx context.Context, params TvSeriesWatchProvidersParams) (res *TvSeriesWatchProvidersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/3/tv/"
	{
		// Encode "series_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "series_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.SeriesID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/watch/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "TvSeriesWatchProviders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTvSeriesWatchProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WatchProviderTvList invokes watch-provider-tv-list operation.
//
// Get the list of streaming providers we have for TV shows.
//
// GET /3/watch/providers/tv
func (c *Client) WatchProviderTvList(ctx context.Context, params WatchProviderTvListParams) (*WatchProviderTvListOK, error) {
	res, err := c.sendWatchProviderTvList(ctx, params)
	return res, err
}

func (c *Client) sendWatchProviderTvList(ctx context.Context, params WatchProviderTvListParams) (res *WatchProviderTvListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/watch/providers/tv"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "watch_region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "watch_region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WatchRegion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "WatchProviderTvList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWatchProviderTvListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WatchProvidersAvailableRegions invokes watch-providers-available-regions operation.
//
// Get the list of the countries we have watch provider (OTT/streaming) data for.
//
// GET /3/watch/providers/regions
func (c *Client) WatchProvidersAvailableRegions(ctx context.Context, params WatchProvidersAvailableRegionsParams) (*WatchProvidersAvailableRegionsOK, error) {
	res, err := c.sendWatchProvidersAvailableRegions(ctx, params)
	return res, err
}

func (c *Client) sendWatchProvidersAvailableRegions(ctx context.Context, params WatchProvidersAvailableRegionsParams) (res *WatchProvidersAvailableRegionsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/watch/providers/regions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "WatchProvidersAvailableRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWatchProvidersAvailableRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WatchProvidersMovieList invokes watch-providers-movie-list operation.
//
// Get the list of streaming providers we have for movies.
//
// GET /3/watch/providers/movie
func (c *Client) WatchProvidersMovieList(ctx context.Context, params WatchProvidersMovieListParams) (*WatchProvidersMovieListOK, error) {
	res, err := c.sendWatchProvidersMovieList(ctx, params)
	return res, err
}

func (c *Client) sendWatchProvidersMovieList(ctx context.Context, params WatchProvidersMovieListParams) (res *WatchProvidersMovieListOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/3/watch/providers/movie"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "watch_region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "watch_region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WatchRegion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySec0(ctx, "WatchProvidersMovieList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Sec0\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWatchProvidersMovieListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
